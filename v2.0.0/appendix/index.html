<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Appendix · Measurements</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Measurements</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../installation/">Installation</a></li><li><a class="toctext" href="../usage/">Usage</a></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../performance/">Performance</a></li><li><a class="toctext" href="../todo/">Development</a></li><li class="current"><a class="toctext" href>Appendix</a><ul class="internal"><li><a class="toctext" href="#The-Measurement-Type-1">The <code>Measurement</code> Type</a></li><li><a class="toctext" href="#Correlation-1">Correlation</a></li><li><a class="toctext" href="#Uncertainty-Propagation-1">Uncertainty Propagation</a></li><li><a class="toctext" href="#Defining-Methods-for-Mathematical-Operations-1">Defining Methods for Mathematical Operations</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Appendix</a></li></ul><a class="edit-page" href="https://github.com/JuliaPhysics/Measurements.jl/blob/master/docs/src/appendix.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Appendix</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Appendix:-Technical-Details-1" href="#Appendix:-Technical-Details-1">Appendix: Technical Details</a></h1><p>This technical appendix explains the design of <code>Measurements.jl</code> package, how it propagates the uncertainties when performing calculations, and how you can contribute by providing new methods for mathematical operations.</p><h2><a class="nav-anchor" id="The-Measurement-Type-1" href="#The-Measurement-Type-1">The <code>Measurement</code> Type</a></h2><p><code>Measurement</code> is a <a href="http://docs.julialang.org/en/stable/manual/types/#composite-types">composite</a> <a href="http://docs.julialang.org/en/stable/manual/types/#man-parametric-types">parametric</a> type, whose parameter is the <code>AbstractFloat</code> subtype of the nominal value and the uncertainty of the measurement. <code>Measurement</code> type itself is subtype of <code>AbstractFloat</code>, thus <code>Measurement</code> objects can be used in any function taking <code>AbstractFloat</code> arguments without redefining it, and calculation of uncertainty will be exact.</p><p>In detail, this is the definition of the type:</p><pre><code class="language-julia">struct Measurement{T&lt;:AbstractFloat} &lt;: AbstractFloat
    val::T
    err::T
    tag::UInt64
    der::Derivatives{T}
end</code></pre><p>The fields represent:</p><ul><li><code>val</code>: the nominal value of the measurement.</li><li><code>err</code>: the uncertainty, assumed to be standard deviation.</li><li><code>tag</code>: a unique identifier, it is used to identify a specific measurement in the list of derivatives. This is a thread-specific counter. The result of mathematical operation will have this field set to <code>0</code> because it is not relevant for non independent measurements.</li><li><code>der</code>: the list of derivates with respect to the independent variables from which this object comes. <code>Derivatives</code> is a lightweight dictionary type. The keys are the tuples <code>(val, err, tag)</code> of all independent variables from which the object has been derived, while the corresponding value is the partial derivative of the object with respect to that independent variable. An independent measurement has this dictionary empty.</li></ul><p>As already explained in the <a href="../usage/#Usage-1">Usage</a> section, every time you use one of the constructors</p><pre><code class="language-julia">measurement(value, uncertainty)
value ± uncertainty</code></pre><p>you define a <em>new independent</em> measurement. This happens because these contructors generate a new unique <code>tag</code> field, that is used to distinguish between really equal objects and measurements that only by chance share the same nominal value and uncertainty. For these reasons,</p><pre><code class="language-julia">julia&gt; x = 24.3 ± 2.7
24.3 ± 2.7

julia&gt; y = 24.3 ± 2.7
24.3 ± 2.7</code></pre><p>will produce two independent measurements and they will be treated as such when performing mathematical operations. In particular, you can also notice that they are not <a href="https://docs.julialang.org/en/stable/base/base/#Core.:===">egal</a></p><pre><code class="language-julia">julia&gt; x === y
false</code></pre><p>If you instead intend to make a variable really the same thing as an independent measurement you have to use assignment:</p><pre><code class="language-julia">julia&gt; a = b = 24.3 ± 2.7
24.3 ± 2.7

julia&gt; a === b
true</code></pre><p>Thanks to how the Julia language is designed, support for complex measurements, arbitrary precision calculations and array operations came with practically no effort during the development of the package. As <a href="https://github.com/JuliaPhysics/Measurements.jl/issues/1#issuecomment-220727553">explained</a> by Steven G. Johnson, since in Julia a lot of nonlinear functions are internally implemented in terms of elementary operations on the real and imaginary parts it was natural to make the type subtype of <code>Real</code> in order to easily work with complex measurements. In particular, it was then chosen to select the <code>AbstractFloat</code> type because some functions of complex arguments (like <code>sqrt</code> and <code>log</code>) take <code>Complex{AbstractFloat}</code> arguments instead of generic <code>Complex{Real}</code>, and any operation on a <code>Measurement{R}</code> object, with <code>R</code> subtype of <code>Real</code> different from <code>AbstractFloat</code>, would turn it into <code>Measurement{F}</code>, with <code>F</code> subtype of <code>AbstractFloat</code>, anyway.</p><h2><a class="nav-anchor" id="Correlation-1" href="#Correlation-1">Correlation</a></h2><p>One must carefully take care of <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a> between two measurements when propagating the uncertainty for an operation. Actually, the term &quot;correlation&quot; may refer to different kind of dependences between two or more quantities, what we mean by this term in <code>Measurements.jl</code> is explained in the <a href="../usage/#Usage-1">Usage</a> section of this manual.</p><p>Dealing with functional correlation between <code>Measurement</code> objects, when using functions with <a href="https://en.wikipedia.org/wiki/Arity">arity</a> larger than one, is an important feature of this package. This is accomplished by keeping inside each <code>Measurement</code> object the list of its derivatives with respect to the independent variables from which the quantity comes.  This role is played by the <code>der</code> field. This dictionary is useful in order to trace the contribution of each measurement and propagate the uncertainty in the case of functions with more than one argument.</p><p>The use of the list of derivatives has been inspired by Python package <a href="https://pythonhosted.org/uncertainties/">uncertainties</a>, but the rest of the implementation of <code>Measurements.jl</code> is completely independent from that of <code>uncertainties</code> package.</p><h2><a class="nav-anchor" id="Uncertainty-Propagation-1" href="#Uncertainty-Propagation-1">Uncertainty Propagation</a></h2><p>For a function <span>$G(a, b, c, \dots)$</span> of real arguments with uncertainties <span>$a = \bar{a} \pm \sigma_{a}$</span>, <span>$b = \bar{b} \pm \sigma_{b}$</span>, and <span>$c = \bar{c} \pm \sigma_{c}$</span>, ..., the <a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty">linear error propagation theory</a> prescribes that uncertainty is propagated as follows:</p><div>\[\begin{aligned}
\sigma_G^2 = \left( \left.\frac{\partial G}{\partial a}\right\vert_{a
= \bar{a}} \sigma_a \right)^2 + \left( \left.\frac{\partial
G}{\partial b}\right\vert_{b = \bar{b}} \sigma_b \right)^2 + \left(
\left.\frac{\partial G}{\partial c}\right\vert_{c = \bar{c}} \sigma_c
\right)^2 + \cdots \\
+ 2 \left(\frac{\partial G}{\partial a}\right)_{a = \bar{a}}
\left(\frac{\partial G}{\partial b}\right)_{b = \bar{b}}
\sigma_{ab} + 2 \left(\frac{\partial G}{\partial a}\right)_{a =
\bar{a}} \left(\frac{\partial G}{\partial c}\right)_{c = \bar{c}}
\sigma_{ac} \\
+ 2 \left(\frac{\partial G}{\partial b}\right)_{b = \bar{b}}
\left(\frac{\partial G}{\partial c}\right)_{c = \bar{c}} \sigma_{bc} +
\dots
\end{aligned}\]</div><p>where the <span>$\sigma_{ab}$</span> factors are the <a href="https://en.wikipedia.org/wiki/Covariance">covariances</a> defined as</p><div>\[\sigma_{ab} = \text{E}[(a - \text{E}[a])(b - \text{E}[b])]\]</div><p><span>$E[a]$</span> is the <a href="https://en.wikipedia.org/wiki/Expected_value">expected value</a>, or mean, of <span>$a$</span>.  If uncertainties of the quantities <span>$a$</span>, <span>$b$</span>, <span>$c$</span>, ..., are independent and normally distributed, the covariances are null and the above formula for uncertainty propagation simplifies to</p><div>\[\sigma_G^2 = \left( \left.\frac{\partial G}{\partial a}\right\vert_{a
= \bar{a}} \sigma_a \right)^2 + \left( \left.\frac{\partial
G}{\partial b}\right\vert_{b = \bar{b}} \sigma_b \right)^2 + \left(
\left.\frac{\partial G}{\partial c}\right\vert_{c = \bar{c}} \sigma_c
\right)^2 + \cdots\]</div><p>In general, calculating the covariances is not an easy task. The trick adopted in <code>Measurements.jl</code> in order to deal with simple functional correlation is to propagate the uncertainty always using really independent variables. Thus, dealing with functional correlation boils down to finding the set of all the independent measurements on which an expression depends. If this set is made up of <span>$\{x, y, z, \dots\}$</span>, it is possible to calculate the uncertainty of <span>$G(a, b, c, \dots)$</span> with</p><div>\[\sigma_G^2 = \left( \left.\frac{\partial G}{\partial x}\right\vert_{x
= \bar{x}} \sigma_x \right)^2 + \left( \left.\frac{\partial
G}{\partial y}\right\vert_{y = \bar{y}} \sigma_y \right)^2 + \left(
\left.\frac{\partial G}{\partial z}\right\vert_{z = \bar{z}} \sigma_z
\right)^2 + \cdots\]</div><p>where all covariances due to functional correlation are null. This explains the purpose of keeping the list of derivatives with respect to independent variables in <code>Measurement</code> objects: by looking at the <code>der</code> fields of <span>$a$</span>, <span>$b$</span>, <span>$c$</span>, ..., it is possible to determine the set of independent variables. If other types of correlation (not functional) between <span>$x$</span>, <span>$y$</span>, <span>$z$</span>, ..., are present, they should be treated by calculating the covariances as shown above.</p><p>For a function of only one argument, <span>$G = G(a)$</span>, there is no problem of correlation and the uncertainty propagation formula in the linear approximation simply reads</p><div>\[\sigma_G = \left\vert \frac{\partial G}{\partial a} \right\vert_{a =
\bar{a}} \sigma_a\]</div><p>even if <span>$a$</span> is not an independent variable and comes from operations on really independent measurements.</p><p>For example, suppose you want to calculate the function <span>$G = G(a, b)$</span> of two arguments, and <span>$a$</span> and <span>$b$</span> are functionally correlated, because they come from some mathematical operations on really independent variables <span>$x$</span>, <span>$y$</span>, <span>$z$</span>, say <span>$a = a(x, y)$</span>, <span>$b = b(x, z)$</span>. By using the <a href="https://en.wikipedia.org/wiki/Chain_rule">chain rule</a>, the uncertainty on <span>$G(a, b)$</span> is calculated as follows:</p><div>\[\sigma_G^2 = \left( \left(\frac{\partial G}{\partial a}\frac{\partial
a}{\partial x} + \frac{\partial G}{\partial b}\frac{\partial
b}{\partial x}\right)_{x = \bar{x}} \sigma_x \right)^2 + \left(
\left(\frac{\partial G}{\partial a}\frac{\partial a}{\partial
y}\right)_{y = \bar{y}} \sigma_y \right)^2 + \left(
\left(\frac{\partial G}{\partial b}\frac{\partial b}{\partial
z}\right)_{z = \bar{z}} \sigma_z \right)^2\]</div><p>What <code>Measurements.jl</code> really does is to calulate the derivatives like <span>$\partial a/\partial x$</span> and <span>$\partial G/\partial x = (\partial G/\partial a)(\partial a/\partial x) + (\partial G/\partial b)(\partial b/\partial x)$</span>, and store them in the <code>der</code> field of <span>$a$</span> and <span>$G$</span> respectively in order to be able to perform further operations involving these quantities.</p><p>This method is also described in the paper by Giordano, M.</p><h2><a class="nav-anchor" id="Defining-Methods-for-Mathematical-Operations-1" href="#Defining-Methods-for-Mathematical-Operations-1">Defining Methods for Mathematical Operations</a></h2><p><code>Measurements.jl</code> defines new methods for mathematical operations in order to make them accept <code>Measurement</code> arguments. The single most important thing to know about how to define new methods in the package is the <code>Measurements.result</code>. This function, not exported because it is intended to be used only within the package, takes care of propagating the uncertainty as described in the section above. It has two methods: one for functions with arity equal to one, and the other for any other case. This is its syntax:</p><pre><code class="language-julia">result(val::Real, der::Real, a::Measurement)</code></pre><p>for functions of one argument, and</p><pre><code class="language-julia">result(val, der, a)</code></pre><p>for functions of two or more arguments.  The arguments are:</p><ul><li><code>val</code>: the nominal result of the operation <span>$G(a, \dots)$</span>;</li><li><code>der</code>: the partial derivative <span>$\partial G/\partial a$</span> of a function <span>$G = G(a)$</span> with respect to the argument <span>$a$</span> for one-argument functions or the tuple of partial derivatives with respect to each argument in other cases;</li><li><code>a</code>: the argument(s) of <span>$G$</span>, in the same order as the corresponding derivatives in <code>der</code> argument.</li></ul><p>In the case of functions with arity larger than one, <code>der</code> and <code>a</code> tuples must have the same length.</p><p>For example, for a one-argument function like <span>$\cos$</span> we have</p><pre><code class="language-julia">cos(a::Measurement) = result(cos(a.val), -sin(a.val), a)</code></pre><p>Instead, the method for subtraction operation is defined as follows:</p><pre><code class="language-julia">-(a::Measurement, b::Measurement) =
    result(a.val - b.val, (1, -1), (a, b))</code></pre><p>Thus, in order to support <code>Measurement</code> argument(s) for a new mathematical operation you have to calculate the result of the operation, the partial derivatives of the functon with respect to all arguments and then pass this information to <code>Measurements.result</code> function.</p><footer><hr/><a class="previous" href="../todo/"><span class="direction">Previous</span><span class="title">Development</span></a></footer></article></body></html>
