<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Measurements</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Measurements</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../installation/">Installation</a></li><li><a class="toctext" href="../usage/">Usage</a></li><li class="current"><a class="toctext" href>Examples</a><ul class="internal"><li><a class="toctext" href="#Measurements-from-Strings-1">Measurements from Strings</a></li><li><a class="toctext" href="#Correlation-Between-Variables-1">Correlation Between Variables</a></li><li><a class="toctext" href="#@uncertain-Macro-1"><code>@uncertain</code> Macro</a></li><li><a class="toctext" href="#Complex-Measurements-1">Complex Measurements</a></li><li><a class="toctext" href="#Arbitrary-Precision-Calculations-1">Arbitrary Precision Calculations</a></li><li><a class="toctext" href="#Operations-with-Arrays-and-Linear-Algebra-1">Operations with Arrays and Linear Algebra</a></li><li><a class="toctext" href="#Derivative,-Gradient-and-Uncertainty-Components-1">Derivative, Gradient and Uncertainty Components</a></li><li><a class="toctext" href="#stdscore-Function-1"><code>stdscore</code> Function</a></li><li><a class="toctext" href="#weightedmean-Function-1"><code>weightedmean</code> Function</a></li><li><a class="toctext" href="#Measurements.value-and-Measurements.uncertainty-Functions-1"><code>Measurements.value</code> and <code>Measurements.uncertainty</code> Functions</a></li><li><a class="toctext" href="#Interplay-with-Third-Party-Packages-1">Interplay with Third-Party Packages</a></li><li><a class="toctext" href="#Integration-with-Plots.jl-1">Integration with <code>Plots.jl</code></a></li></ul></li><li><a class="toctext" href="../performance/">Performance</a></li><li><a class="toctext" href="../todo/">Development</a></li><li><a class="toctext" href="../appendix/">Appendix</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Examples</a></li></ul><a class="edit-page" href="https://github.com/JuliaPhysics/Measurements.jl/blob/master/docs/src/examples.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Examples</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h1><p>These are some basic examples of use of the package:</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; a = measurement(4.5, 0.1)
4.5 ± 0.1

julia&gt; b = 3.8 ± 0.4
3.8 ± 0.4

julia&gt; 2a + b
12.8 ± 0.45

julia&gt; a - 1.2b
-0.06 ± 0.49

julia&gt; l = measurement(0.936, 1e-3);

julia&gt; T = 1.942 ± 4e-3;

julia&gt; g = 4pi^2*l/T^2
9.798 ± 0.042

julia&gt; c = measurement(4)
4.0 ± 0.0

julia&gt; a*c
18.0 ± 0.4

julia&gt; sind(94 ± 1.2)
0.9976 ± 0.0015

julia&gt; x = 5.48 ± 0.67;

julia&gt; y = 9.36 ± 1.02;

julia&gt; log(2x^2 - 3.4y)
3.34 ± 0.53

julia&gt; atan(y, x)
1.041 ± 0.071</code></pre><h2><a class="nav-anchor" id="Measurements-from-Strings-1" href="#Measurements-from-Strings-1">Measurements from Strings</a></h2><p>You can construct <code>Measurement{Float64}</code> objects from strings. Within parentheses there is the uncertainty referred to the corresponding last digits.</p><pre><code class="language-julia-repl">julia&gt; measurement(&quot;-12.34(56)&quot;)
-12.34 ± 0.56

julia&gt; measurement(&quot;+1234(56)e-2&quot;)
12.34 ± 0.56

julia&gt; measurement(&quot;123.4e-1 +- 0.056e1&quot;)
12.34 ± 0.56

julia&gt; measurement(&quot;(-1.234 ± 0.056)e1&quot;)
-12.34 ± 0.56

julia&gt; measurement(&quot;1234e-2 +/- 0.56e0&quot;)
12.34 ± 0.56

julia&gt; measurement(&quot;-1234e-2&quot;)
-12.34 ± 0.0</code></pre><p>It is also possible to use <code>parse(Measurement{T}, string)</code> to parse the <code>string</code> as a <code>Measurement{T}</code>, with <code>T&lt;:AbstractFloat</code>. This has been tested with standard numeric floating types (<code>Float16</code>, <code>Float32</code>, <code>Float64</code>, and <code>BigFloat</code>).</p><pre><code class="language-julia-repl">julia&gt; parse(Measurement{Float16}, &quot;19.5 ± 2.8&quot;)
19.5 ± 2.8

julia&gt; parse(Measurement{Float32}, &quot;-7.6 ± 0.4&quot;)
-7.6 ± 0.4

julia&gt; parse(Measurement{Float64}, &quot;4 ± 1.3&quot;)
4.0 ± 1.3

julia&gt; parse(Measurement{BigFloat}, &quot;+5.1 ± 3.3&quot;)
5.099999999999999999999999999999999999999999999999999999999999999999999999999986 ± 3.299999999999999999999999999999999999999999999999999999999999999999999999999993</code></pre><h2><a class="nav-anchor" id="Correlation-Between-Variables-1" href="#Correlation-Between-Variables-1">Correlation Between Variables</a></h2><p>Here you can see examples of how functionally correlated variables are treated within the package:</p><pre><code class="language-julia-repl">julia&gt; x = 8.4 ± 0.7
8.4 ± 0.7

julia&gt; x - x
0.0 ± 0.0
julia&gt; x/x
1.0 ± 0.0

julia&gt; x*x*x - x^3
0.0 ± 0.0

julia&gt; sin(x)/cos(x) - tan(x) # They are equal within numerical accuracy
-2.220446049250313e-16 ± 0.0

julia&gt; y = -5.9 ± 0.2;

julia&gt; beta(x, y) - gamma(x)*gamma(y)/gamma(x + y)
2.8e-14 ± 4.0e-14</code></pre><p>You will get similar results for a variable that is a function of an already existing <code>Measurement</code> object:</p><pre><code class="language-julia-repl">julia&gt; x = 8.4 ± 0.7;

julia&gt; u = 2x;

julia&gt; (x + x) - u
0.0 ± 0.0

julia&gt; u/2x
1.0 ± 0.0

julia&gt; u^3 - 8x^3
0.0 ± 0.0

julia&gt; cos(x)^2 - (1 + cos(u))/2
0.0 ± 0.0</code></pre><p>A variable that has the same nominal value and uncertainty as <code>u</code> above but is not functionally correlated with <code>x</code> will give different outcomes:</p><pre><code class="language-julia-repl">julia&gt; x = 8.4 ± 0.7;

julia&gt; v = 16.8 ± 1.4;

julia&gt; (x + x) - v
0.0 ± 2.0

julia&gt; v / 2x
1.0 ± 0.12

julia&gt; v^3 - 8x^3
0.0 ± 1700.0

julia&gt; cos(x)^2 - (1 + cos(v))/2
0.0 ± 0.88</code></pre><h2><a class="nav-anchor" id="@uncertain-Macro-1" href="#@uncertain-Macro-1"><code>@uncertain</code> Macro</a></h2><p>Macro <a href="../usage/#Measurements.@uncertain"><code>@uncertain</code></a> can be used to propagate uncertainty in arbitrary real or complex functions of real arguments, including functions not natively supported by this package.</p><pre><code class="language-julia-repl">julia&gt; @uncertain (x -&gt; complex(zeta(x), exp(eta(x)^2)))(2 ± 0.13)
(1.64 ± 0.12) + (1.967 ± 0.043)im

julia&gt; @uncertain log(9.4 ± 1.3, 58.8 ± 3.7)
1.82 ± 0.12

julia&gt; log(9.4 ± 1.3, 58.8 ± 3.7) # Exact result
1.82 ± 0.12

julia&gt; @uncertain atan(10, 13.5 ± 0.8)
0.638 ± 0.028

julia&gt; atan(10, 13.5 ± 0.8) # Exact result
0.638 ± 0.028</code></pre><p>You usually do not need to define a wrapping function before using it.  In the case where you have to define a function, like in the first line of previous examples, <a href="http://docs.julialang.org/en/stable/manual/functions/#anonymous-functions">anonymous functions</a> allow you to do it in a very concise way.</p><p>The macro works with functions calling C/Fortran functions as well. For example, <a href="https://github.com/giordano/Cuba.jl">Cuba.jl</a> package performs numerical integration by wrapping the C <a href="http://www.feynarts.de/cuba/">Cuba</a> library. You can define a function to numerically compute with <code>Cuba.jl</code> the integral defining the <a href="https://en.wikipedia.org/wiki/Error_function">error function</a> and pass it to <code>@uncertain</code> macro. Compare the result with that of the <code>erf</code> function, natively supported in <code>Measurements.jl</code> package</p><pre><code class="language-julia-repl">julia&gt; using Cuba

julia&gt; cubaerf(x::Real) =
           2x/sqrt(pi)*cuhre((t, f) -&gt; f[1] = exp(-abs2(t[1]*x)))[1][1]
cubaerf (generic function with 1 method)

julia&gt; @uncertain cubaerf(0.5 ± 0.01)
0.5205 ± 0.0088

julia&gt; erf(0.5 ± 0.01) # Exact result
0.5205 ± 0.0088</code></pre><p>Also here you can use an anonymous function instead of defining the <code>cubaerf</code> function, do it as an exercise. Remember that if you want to numerically integrate a function that returns a <code>Measurement</code> object you can use <code>QuadGK.jl</code> package, which is written purely in Julia and in addition allows you to set <code>Measurement</code> objects as endpoints, see below.</p><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>Note that the argument of <code>@uncertain</code> macro must be a function call. Thus,</p><pre><code class="language-julia">julia&gt; @uncertain zeta(13.4 ± 0.8) + eta(8.51 ± 0.67)</code></pre><p>will not work because here the outermost function is <code>+</code>, whose arguments are <code>zeta(13.4 ± 0.8)</code> and <code>eta(8.51 ± 0.67)</code>, that however cannot be calculated. You can use the <code>@uncertain</code> macro on each function separately:</p><pre><code class="language-julia-repl">julia&gt; @uncertain(zeta(13.4 ± 0.8)) +  @uncertain(eta(8.51 ± 0.67))
1.9974 ± 0.0012</code></pre><p>In addition, the function must be differentiable in all its arguments. For example, the polygamma function of order <span>$m$</span>, <code>polygamma(m, x)</code>, is the <span>$m+1$</span>-th derivative of the logarithm of gamma function, and is not differentiable in the first argument, because the first argument must be an integer. You can easily work around this limitation by wrapping the function in a single-argument function:</p><pre><code class="language-julia-repl">julia&gt; @uncertain (x -&gt; polygamma(0, x))(4.8 ± 0.2)
1.461 ± 0.046

julia&gt; digamma(4.8 ± 0.2)   # Exact result
1.461 ± 0.046</code></pre></div></div><h2><a class="nav-anchor" id="Complex-Measurements-1" href="#Complex-Measurements-1">Complex Measurements</a></h2><p>Here are a few examples about uncertainty propagation of complex-valued measurements.</p><pre><code class="language-julia-repl">julia&gt; u = complex(32.7 ± 1.1, -3.1 ± 0.2);

julia&gt; v = complex(7.6 ± 0.9, 53.2 ± 3.4);

julia&gt; 2u + v
(73.0 ± 2.4) + (47.0 ± 3.4)im

julia&gt; sqrt(u * v)
(33.0 ± 1.1) + (26.0 ± 1.1)im</code></pre><p>You can also verify the <a href="https://en.wikipedia.org/wiki/Euler%27s_formula">Euler&#39;s formula</a></p><pre><code class="language-julia-repl">julia&gt; u = complex(32.7 ± 1.1, -3.1 ± 0.2);

julia&gt; cis(u)
(6.0 ± 23.0) + (21.3 ± 8.1)im

julia&gt; cos(u) + sin(u)*im
(6.0 ± 23.0) + (21.3 ± 8.1)im</code></pre><h2><a class="nav-anchor" id="Arbitrary-Precision-Calculations-1" href="#Arbitrary-Precision-Calculations-1">Arbitrary Precision Calculations</a></h2><p>If you performed an exceptionally good experiment that gave you extremely precise results (that is, with very low relative error), you may want to use <a href="http://docs.julialang.org/en/stable/manual/integers-and-floating-point-numbers/#arbitrary-precision-arithmetic">arbitrary precision</a> (or multiple precision) calculations, in order not to loose significance of the experimental results. Luckily, Julia natively supports this type of arithmetic and so <code>Measurements.jl</code> does. You only have to create <code>Measurement</code> objects with nominal value and uncertainty of type <code>BigFloat</code>.</p><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>As explained in the <a href="http://docs.julialang.org/en/stable/stdlib/numbers/#Base.BigFloat">Julia documentation</a>, it is better to use the <code>big</code> string literal to initialize an arbitrary precision floating point constant, instead of the <code>BigFloat</code> and <code>big</code> functions. See examples below.</p></div></div><p>For example, you want to measure a quantity that is the product of two observables <span>$a$</span> and <span>$b$</span>, and the expected value of the product is <span>$12.00000007$</span>. You measure <span>$a = 3.00000001 \pm (1\times 10^{-17})$</span> and <span>$b = 4.0000000100000001 \pm (1\times 10^{-17})$</span> and want to compute the standard score of the product with <a href="../usage/#Measurements.stdscore"><code>stdscore</code></a>. Using the ability of <code>Measurements.jl</code> to perform arbitrary precision calculations you discover that</p><pre><code class="language-julia-repl">julia&gt; a = big&quot;3.00000001&quot; ± big&quot;1e-17&quot;;

julia&gt; b = big&quot;4.0000000100000001&quot; ± big&quot;1e-17&quot;;

julia&gt; stdscore(a * b, big&quot;12.00000007&quot;)
7.999999997599999878080000420160000093695993825308195353920411656927305928530607</code></pre><p>the measurement significantly differs from the expected value and you make a great discovery. Instead, if you used double precision accuracy, you would have wrongly found that your measurement is consistent with the expected value:</p><pre><code class="language-julia-repl">julia&gt; stdscore((3.00000001 ± 1e-17)*(4.0000000100000001 ± 1e-17), 12.00000007)
0.0</code></pre><p>and you would have missed an important prize due to the use of an incorrect arithmetic.</p><p>Of course, you can perform any mathematical operation supported in <code>Measurements.jl</code> using arbitrary precision arithmetic:</p><pre><code class="language-julia-repl">julia&gt; a = big&quot;3.00000001&quot; ± big&quot;1e-17&quot;;

julia&gt; b = big&quot;4.0000000100000001&quot; ± big&quot;1e-17&quot;;

julia&gt; hypot(a, b)
5.000000014000000080000000000000000000000000000000000000000000000000000000000013 ± 9.999999999999999999999999999999999999999999999999999999999999999999999999999967e-18

julia&gt; log(2a) ^ b
1.030668110995484998100000000000000000000000000000000000000000000000000000000005e+01 ± 9.699999999999999999999999999999999999999999999999999999999999999999999999999966e-17</code></pre><h2><a class="nav-anchor" id="Operations-with-Arrays-and-Linear-Algebra-1" href="#Operations-with-Arrays-and-Linear-Algebra-1">Operations with Arrays and Linear Algebra</a></h2><p>You can create arrays of <code>Measurement</code> objects and perform mathematical operations on them in the most natural way possible:</p><pre><code class="language-julia-repl">julia&gt; A = [1.03 ± 0.14, 2.88 ± 0.35, 5.46 ± 0.97]
3-element Array{Measurement{Float64},1}:
 1.03 ± 0.14
 2.88 ± 0.35
 5.46 ± 0.97

julia&gt; B = [0.92 ± 0.11, 3.14 ± 0.42, 4.67 ± 0.58]
3-element Array{Measurement{Float64},1}:
 0.92 ± 0.11
 3.14 ± 0.42
 4.67 ± 0.58

julia&gt; exp.(sqrt.(B)) .- log.(A)
3-element Array{Measurement{Float64},1}:
 2.5799612193837493 ± 0.20215123893809778
  4.824843081566397 ± 0.7076631767039828
  6.982522998771526 ± 1.178287422979362

julia&gt; @. cos(A) ^ 2 + sin(A) ^ 2
3-element Array{Measurement{Float64},1}:
 1.0 ± 0.0
 1.0 ± 0.0
 1.0 ± 0.0</code></pre><p>If you originally have separate arrays of values and uncertainties, you can create an array of <code>Measurement</code> objects using <code>measurement</code> or <code>±</code> with the <a href="http://docs.julialang.org/en/stable/manual/functions/#man-dot-vectorizing">dot syntax</a> for vectorizing functions:</p><pre><code class="language-julia-repl">julia&gt; using Statistics

julia&gt; C = measurement.([174.9, 253.8, 626.3], [12.2, 19.4, 38.5])
3-element Array{Measurement{Float64},1}:
 174.9 ± 12.2
 253.8 ± 19.4
 626.3 ± 38.5

julia&gt; sum(C)
1055.0 ± 45.0

julia&gt; D = [549.4, 672.3, 528.5] .± [7.4, 9.6, 5.2]
3-element Array{Measurement{Float64},1}:
 549.4 ± 7.4
 672.3 ± 9.6
 528.5 ± 5.2

julia&gt; mean(D)
583.4 ± 4.4</code></pre><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p><code>prod</code> and <code>sum</code> (and <code>mean</code>, which relies on <code>sum</code>) functions work out-of-the-box with any iterable of <code>Measurement</code> objects, like arrays or tuples. However, these functions have faster methods (quadratic in the number of elements) when operating on an array of <code>Measurement</code> s than on a tuple (in this case the computational complexity is cubic in the number of elements), so you should use an array if performance is crucial for you, in particular for large collections of measurements.</p></div></div><p>Some <a href="http://docs.julialang.org/en/stable/stdlib/linalg/">linear algebra</a> functions work out-of-the-box, without defining specific methods for them. For example, you can solve linear systems, do matrix multiplication and dot product between vectors, find inverse, determinant, and trace of a matrix, do LU and QR factorization, etc.</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra

julia&gt; A = [(14 ± 0.1) (23 ± 0.2); (-12 ± 0.3) (24 ± 0.4)]
2×2 Array{Measurement{Float64},2}:
  14.0±0.1  23.0±0.2
 -12.0±0.3  24.0±0.4

julia&gt; b = [(7 ± 0.5), (-13 ± 0.6)]
2-element Array{Measurement{Float64},1}:
   7.0 ± 0.5
 -13.0 ± 0.6

julia&gt; x = A \ b
2-element Array{Measurement{Float64},1}:
   0.7630718954248366 ± 0.03135711295001047
 -0.16013071895424838 ± 0.017796338417650402

julia&gt; A * x ≈ b
true

julia&gt; dot(x, b)
7.42 ± 0.6

julia&gt; det(A)
612.0 ± 9.5

julia&gt; tr(A)
38.0 ± 0.41

julia&gt; A * inv(A) ≈ Matrix{eltype(A)}(I, size(A))
true

julia&gt; lu(A)
LinearAlgebra.LU{Measurement{Float64},Array{Measurement{Float64},2}}
L factor:
2×2 Array{Measurement{Float64},2}:
       1.0±0.0        0.0±0.0
 -0.857143±0.0222861  1.0±0.0
U factor:
2×2 Array{Measurement{Float64},2}:
 14.0±0.1     23.0±0.2
  0.0±0.0  43.7143±0.672403

julia&gt; qr(A)
LinearAlgebra.QR{Measurement{Float64},Array{Measurement{Float64},2}}
Q factor:
2×2 LinearAlgebra.QRPackedQ{Measurement{Float64},Array{Measurement{Float64},2}}:
 -0.759257±0.00836088  0.650791±0.00975436
  0.650791±0.00975436  0.759257±0.00836088
R factor:
2×2 Array{Measurement{Float64},2}:
 -18.4391±0.209481  -1.84391±0.522154
      0.0±0.0        33.1904±0.331267</code></pre><h2><a class="nav-anchor" id="Derivative,-Gradient-and-Uncertainty-Components-1" href="#Derivative,-Gradient-and-Uncertainty-Components-1">Derivative, Gradient and Uncertainty Components</a></h2><p>In order to propagate the uncertainties, <code>Measurements.jl</code> keeps track of the partial derivative of an expression with respect to all independent measurements from which the expression comes. The package provides a convenient function, <a href="../usage/#Measurements.derivative"><code>Measurements.derivative</code></a>, that returns the partial derivative of an expression with respect to independent measurements. Its vectorized version can be used to compute the gradient of an expression with respect to multiple independent measurements.</p><pre><code class="language-julia-repl">julia&gt; x = 98.1 ± 12.7
98.0 ± 13.0

julia&gt; y = 105.4 ± 25.6
105.0 ± 26.0

julia&gt; z = 78.3 ± 14.1
78.0 ± 14.0

julia&gt; Measurements.derivative(2x - 4y, x)
2.0

julia&gt; Measurements.derivative(2x - 4y, y)
-4.0

julia&gt; Measurements.derivative.(log1p(x) + y^2 - cos(x/y), [x, y, z])
3-element Array{Float64,1}:
   0.017700515090289737
 210.7929173496422
   0.0</code></pre><p>The last resul shows that the expression does not depend on <code>z</code>.</p><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>The vectorized version of <code>Measurements.derivative</code> is useful in order to discover which variable contributes most to the total uncertainty of a given expression, if you want to minimize it. This can be calculated as the <a href="https://en.wikipedia.org/wiki/Hadamard_product_%28matrices%29">Hadamard (element-wise) product</a> between the gradient of the expression with respect to the set of variables and the vector of uncertainties of the same variables in the same order. For example:</p><pre><code class="language-julia">julia&gt; w = y^(3//4)*log(y) + 3x - cos(y/x)
447.0410543780643 ± 52.41813324207829

julia&gt; abs.(Measurements.derivative.(w, [x, y]) .* Measurements.uncertainty.([x, y]))
2-element Array{Float64,1}:
 37.9777
 36.1297</code></pre><p>In this case, the <code>x</code> variable contributes most to the uncertainty of <code>w</code>. In addition, note that the <a href="https://en.wikipedia.org/wiki/Euclidean_norm">Euclidean norm</a> of the Hadamard product above is exactly the total uncertainty of the expression:</p><pre><code class="language-julia">julia&gt; vecnorm(Measurements.derivative.(w, [x, y]) .* Measurements.uncertainty.([x, y]))
52.41813324207829</code></pre><p>The <a href="../usage/#Measurements.uncertainty_components"><code>Measurements.uncertainty_components</code></a> function simplifies calculation of all uncertainty components of a derived quantity:</p><pre><code class="language-julia">julia&gt; Measurements.uncertainty_components(w)
Dict{Tuple{Float64,Float64,Float64},Float64} with 2 entries:
  (98.1, 12.7, 0.303638)  =&gt; 37.9777
  (105.4, 25.6, 0.465695) =&gt; 36.1297

julia&gt; norm(collect(values(Measurements.uncertainty_components(w))))
52.41813324207829</code></pre></div></div><h2><a class="nav-anchor" id="stdscore-Function-1" href="#stdscore-Function-1"><code>stdscore</code> Function</a></h2><p>You can get the distance in number of standard deviations between a measurement and its expected value (not a <code>Measurement</code>) using <a href="../usage/#Measurements.stdscore"><code>stdscore</code></a>:</p><pre><code class="language-julia-repl">julia&gt; stdscore(1.3 ± 0.12, 1)
2.5000000000000004</code></pre><p>You can use the same function also to test the consistency of two measurements by computing the standard score between their difference and zero. This is what <a href="../usage/#Measurements.stdscore"><code>stdscore</code></a> does when both arguments are <code>Measurement</code> objects:</p><pre><code class="language-julia-repl">julia&gt; stdscore((4.7 ± 0.58) - (5 ± 0.01), 0)
-0.5171645175253433

julia&gt; stdscore(4.7 ± 0.58, 5 ± 0.01)
-0.5171645175253433</code></pre><h2><a class="nav-anchor" id="weightedmean-Function-1" href="#weightedmean-Function-1"><code>weightedmean</code> Function</a></h2><p>Calculate the weighted and arithmetic means of your set of measurements with <a href="../usage/#Measurements.weightedmean"><code>weightedmean</code></a> and <code>mean</code> respectively:</p><pre><code class="language-julia-repl">julia&gt; weightedmean((3.1±0.32, 3.2±0.38, 3.5±0.61, 3.8±0.25))
3.47 ± 0.17

julia&gt; using Statistics

julia&gt; mean((3.1±0.32, 3.2±0.38, 3.5±0.61, 3.8±0.25))
3.4 ± 0.21</code></pre><h2><a class="nav-anchor" id="Measurements.value-and-Measurements.uncertainty-Functions-1" href="#Measurements.value-and-Measurements.uncertainty-Functions-1"><code>Measurements.value</code> and <code>Measurements.uncertainty</code> Functions</a></h2><p>Use <a href="../usage/#Measurements.value"><code>Measurements.value</code></a> and <a href="../usage/#Measurements.uncertainty"><code>Measurements.uncertainty</code></a> to get the values and uncertainties of measurements. They work with real and complex measurements, scalars or arrays:</p><pre><code class="language-julia-repl">julia&gt; Measurements.value(94.5 ± 1.6)
94.5

julia&gt; Measurements.uncertainty(94.5 ± 1.6)
1.6

julia&gt; Measurements.value.([complex(87.3 ± 2.9, 64.3 ± 3.0), complex(55.1 ± 2.8, -19.1 ± 4.6)])
2-element Array{Complex{Float64},1}:
 87.3 + 64.3im
 55.1 - 19.1im

julia&gt; Measurements.uncertainty.([complex(87.3 ± 2.9, 64.3 ± 3.0), complex(55.1 ± 2.8, -19.1 ± 4.6)])
2-element Array{Complex{Float64},1}:
 2.9 + 3.0im
 2.8 + 4.6im</code></pre><h2><a class="nav-anchor" id="Interplay-with-Third-Party-Packages-1" href="#Interplay-with-Third-Party-Packages-1">Interplay with Third-Party Packages</a></h2><p><code>Measurements.jl</code> works out-of-the-box with any function taking arguments no more specific than <code>AbstractFloat</code>. This makes this library particularly suitable for cooperating with well-designed third-party packages in order to perform complicated calculations always accurately taking care of uncertainties and their correlations, with no effort for the developers nor users.</p><p>The following sections present a sample of packages that are known to work with <code>Measurements.jl</code>, but many others will interplay with this package as well as them.</p><h3><a class="nav-anchor" id="Numerical-Integration-with-QuadGK.jl-1" href="#Numerical-Integration-with-QuadGK.jl-1">Numerical Integration with <code>QuadGK.jl</code></a></h3><p>The powerful integration routine <code>quadgk</code> from <code>QuadGK.jl</code> package is smart enough to support out-of-the-box integrand functions that return arbitrary types, including <code>Measurement</code>:</p><pre><code class="language-julia-repl">julia&gt; a = 4.71 ± 0.01;

julia&gt; quadgk(x -&gt; exp(x / a), 1, 7)[1]
14.995 ± 0.031</code></pre><p><code>Measurements.jl</code> pushes the capabilities of <code>quadgk</code> further by supporting also <code>Measurement</code> objects as endpoints:</p><pre><code class="language-julia-repl">julia&gt; quadgk(cos, 1.19 ± 0.02, 8.37 ± 0.05)[1]
-0.059 ± 0.026</code></pre><p>Compare this with the expected result:</p><pre><code class="language-julia-repl">julia&gt; sin(8.37 ± 0.05) - sin(1.19 ± 0.02)
-0.059 ± 0.026</code></pre><p>Also with <code>quadgk</code> correlation is properly taken into account:</p><pre><code class="language-julia-repl">julia&gt; a = 6.42 ± 0.03
6.42 ± 0.03

julia&gt; quadgk(sin, -a, a)
(2.484178227707412e-17 ± 0.0, 0.0)</code></pre><p>If instead the two endpoints have, by chance, the same nominal value and uncertainty but are not correlated:</p><pre><code class="language-julia-repl">julia&gt; quadgk(sin, -6.42 ± 0.03, 6.42 ± 0.03)
(2.484178227707412e-17 ± 0.005786464233000303, 0.0)</code></pre><h3><a class="nav-anchor" id="Numerical-and-Automatic-Differentiation-1" href="#Numerical-and-Automatic-Differentiation-1">Numerical and Automatic Differentiation</a></h3><p>With <a href="https://github.com/JuliaMath/Calculus.jl">Calculus.jl</a> package it is possible to perform numerical differentiation using finite differencing. You can pass in to the <code>Calculus.derivative</code> function both functions returning <code>Measurement</code> objects and a <code>Measurement</code> as the point in which to calculate the derivative.</p><pre><code class="language-julia-repl">julia&gt; using Measurements, Calculus

julia&gt; a = -45.7 ± 1.6
-45.7 ± 1.6

julia&gt; b = 36.5 ± 6.0
36.5 ± 6.0

julia&gt; Calculus.derivative(exp, a) ≈ exp(a)
true

julia&gt; Calculus.derivative(cos, b) ≈ -sin(b)
true

julia&gt; Calculus.derivative(t -&gt; log(-t * b)^2, a) ≈ 2log(-a * b)/a
true</code></pre><p>Other packages provide <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a> methods. Here is an example with <a href="https://github.com/denizyuret/AutoGrad.jl">AutoGrad.jl</a>, just one of the packages available:</p><pre><code class="language-julia">julia&gt; using AutoGrad

julia&gt; grad(exp)(a) ≈ exp(a)
true

julia&gt; grad(cos)(b) ≈ -sin(b)
true

julia&gt; grad(t -&gt; log(-t * b)^2)(a) ≈ 2log(-a * b)/a
true</code></pre><p>However remember that you can always use <a href="../usage/#Measurements.derivative"><code>Measurements.derivative</code></a> to compute the value (without uncertainty) of the derivative of a <code>Measurement</code> object.</p><h3><a class="nav-anchor" id="Use-with-SIUnits.jl-and-Unitful.jl-1" href="#Use-with-SIUnits.jl-and-Unitful.jl-1">Use with <code>SIUnits.jl</code> and <code>Unitful.jl</code></a></h3><p>You can use <code>Measurements.jl</code> in combination with a third-party package in order to perform calculations involving physical measurements, i.e. numbers with uncertainty and physical unit. The details depend on the specific package adopted. Such packages are, for instance, <a href="https://github.com/Keno/SIUnits.jl">SIUnits.jl</a> and <a href="https://github.com/ajkeller34/Unitful.jl">Unitful.jl</a>. You only have to use the <code>Measurement</code> object as the value of the <code>SIQuantity</code> object (for <code>SIUnits.jl</code>) or of the <code>Quantity</code> object (for <code>Unitful.jl</code>). Here are a few examples.</p><pre><code class="language-julia">julia&gt; using Measurements, SIUnits, SIUnits.ShortUnits

julia&gt; hypot((3 ± 1)*m, (4 ± 2)*m) # Pythagorean theorem
5.0 ± 1.7088007490635064 m

julia&gt; (50 ± 1)Ω * (13 ± 2.4)*1e-2*A # Ohm&#39;s Law
6.5 ± 1.20702112657567 kg m²s⁻³A⁻¹

julia&gt; 2pi*sqrt((5.4 ± 0.3)*m / ((9.81 ± 0.01)*m/s^2)) # Pendulum&#39;s  period
4.661677707464357 ± 0.1295128435999655 s

julia&gt; using Measurements, Unitful

julia&gt; hypot((3 ± 1)*u&quot;m&quot;, (4 ± 2)*u&quot;m&quot;) # Pythagorean theorem
5.0 ± 1.7088007490635064 m

julia&gt; (50 ± 1)*u&quot;Ω&quot; * (13 ± 2.4)*1e-2*u&quot;A&quot; # Ohm&#39;s Law
6.5 ± 1.20702112657567 A Ω

julia&gt; 2pi*sqrt((5.4 ± 0.3)*u&quot;m&quot; / ((9.81 ± 0.01)*u&quot;m/s^2&quot;)) # Pendulum&#39;s period
4.661677707464357 ± 0.12951284359996548 s</code></pre><h2><a class="nav-anchor" id="Integration-with-Plots.jl-1" href="#Integration-with-Plots.jl-1">Integration with <code>Plots.jl</code></a></h2><p><code>Measurements.jl</code> provides plot recipes for the Julia graphic framework <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>. Arguments to <code>plot</code> function that have <code>Measurement</code> type will be automatically represented with errorbars.</p><pre><code class="language-julia">julia&gt; using Measurements, Plots

julia&gt; plot(sin, [x ± 0.1 for x in 1:0.2:10], size = (1200, 800))</code></pre><p><img src="../plot-example.png" alt="image"/></p><footer><hr/><a class="previous" href="../usage/"><span class="direction">Previous</span><span class="title">Usage</span></a><a class="next" href="../performance/"><span class="direction">Next</span><span class="title">Performance</span></a></footer></article></body></html>
