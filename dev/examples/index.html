<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Measurements</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Measurements</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Measurements-from-Strings"><span>Measurements from Strings</span></a></li><li><a class="tocitem" href="#Correlation-Between-Variables"><span>Correlation Between Variables</span></a></li><li><a class="tocitem" href="#@uncertain-Macro"><span><code>@uncertain</code> Macro</span></a></li><li><a class="tocitem" href="#Complex-Measurements"><span>Complex Measurements</span></a></li><li><a class="tocitem" href="#Missing-Measurements"><span>Missing Measurements</span></a></li><li><a class="tocitem" href="#Arbitrary-Precision-Calculations"><span>Arbitrary Precision Calculations</span></a></li><li><a class="tocitem" href="#Operations-with-Arrays-and-Linear-Algebra"><span>Operations with Arrays and Linear Algebra</span></a></li><li><a class="tocitem" href="#Derivative,-Gradient-and-Uncertainty-Components"><span>Derivative, Gradient and Uncertainty Components</span></a></li><li><a class="tocitem" href="#stdscore-Function"><span><code>stdscore</code> Function</span></a></li><li><a class="tocitem" href="#weightedmean-Function"><span><code>weightedmean</code> Function</span></a></li><li><a class="tocitem" href="#Measurements.value-and-Measurements.uncertainty-Functions"><span><code>Measurements.value</code> and <code>Measurements.uncertainty</code> Functions</span></a></li><li><a class="tocitem" href="#Interplay-with-Third-Party-Packages"><span>Interplay with Third-Party Packages</span></a></li><li><a class="tocitem" href="#Integration-with-Plots.jl"><span>Integration with <code>Plots.jl</code></span></a></li></ul></li><li><a class="tocitem" href="../performance/">Performance</a></li><li><a class="tocitem" href="../todo/">Development</a></li><li><a class="tocitem" href="../appendix/">Appendix</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPhysics/Measurements.jl/blob/master/docs/src/examples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>These are some basic examples of use of the package:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = measurement(4.5, 0.1)</code><code class="nohighlight hljs ansi" style="display:block;">4.5 ± 0.1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = 3.8 ± 0.4</code><code class="nohighlight hljs ansi" style="display:block;">3.8 ± 0.4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2a + b</code><code class="nohighlight hljs ansi" style="display:block;">12.8 ± 0.45</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a - 1.2b</code><code class="nohighlight hljs ansi" style="display:block;">-0.06 ± 0.49</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; l = measurement(0.936, 1e-3);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; T = 1.942 ± 4e-3;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; g = 4pi^2*l/T^2</code><code class="nohighlight hljs ansi" style="display:block;">9.798 ± 0.042</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = measurement(4)</code><code class="nohighlight hljs ansi" style="display:block;">4.0 ± 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a*c</code><code class="nohighlight hljs ansi" style="display:block;">18.0 ± 0.4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sind(94 ± 1.2)</code><code class="nohighlight hljs ansi" style="display:block;">0.9976 ± 0.0015</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 5.48 ± 0.67;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = 9.36 ± 1.02;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; log(2x^2 - 3.4y)</code><code class="nohighlight hljs ansi" style="display:block;">3.34 ± 0.53</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atan(y, x)</code><code class="nohighlight hljs ansi" style="display:block;">1.041 ± 0.071</code></pre><h2 id="Measurements-from-Strings"><a class="docs-heading-anchor" href="#Measurements-from-Strings">Measurements from Strings</a><a id="Measurements-from-Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Measurements-from-Strings" title="Permalink"></a></h2><p>You can construct <code>Measurement{Float64}</code> objects from strings. Within parentheses there is the uncertainty referred to the corresponding last digits.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; measurement(&quot;-12.34(56)&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">-12.34 ± 0.56</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; measurement(&quot;+1234(56)e-2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">12.34 ± 0.56</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; measurement(&quot;123.4e-1 +- 0.056e1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">12.34 ± 0.56</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; measurement(&quot;(-1.234 ± 0.056)e1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">-12.34 ± 0.56</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; measurement(&quot;1234e-2 +/- 0.56e0&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">12.34 ± 0.56</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; measurement(&quot;-1234e-2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">-12.34 ± 0.0</code></pre><p>It is also possible to use <code>parse(Measurement{T}, string)</code> to parse the <code>string</code> as a <code>Measurement{T}</code>, with <code>T&lt;:AbstractFloat</code>. This has been tested with standard numeric floating types (<code>Float16</code>, <code>Float32</code>, <code>Float64</code>, and <code>BigFloat</code>).</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; parse(Measurement{Float16}, &quot;19.5 ± 2.8&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">19.5 ± 2.8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; parse(Measurement{Float32}, &quot;-7.6 ± 0.4&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">-7.6 ± 0.4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; parse(Measurement{Float64}, &quot;4 ± 1.3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">4.0 ± 1.3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; parse(Measurement{BigFloat}, &quot;+5.1 ± 3.3&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">5.099999999999999999999999999999999999999999999999999999999999999999999999999986 ± 3.299999999999999999999999999999999999999999999999999999999999999999999999999993</code></pre><h2 id="Correlation-Between-Variables"><a class="docs-heading-anchor" href="#Correlation-Between-Variables">Correlation Between Variables</a><a id="Correlation-Between-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Correlation-Between-Variables" title="Permalink"></a></h2><p>Here you can see examples of how functionally correlated variables are treated within the package:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, SpecialFunctions</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 8.4 ± 0.7</code><code class="nohighlight hljs ansi" style="display:block;">8.4 ± 0.7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x - x</code><code class="nohighlight hljs ansi" style="display:block;">0.0 ± 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x/x</code><code class="nohighlight hljs ansi" style="display:block;">1.0 ± 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x*x*x - x^3</code><code class="nohighlight hljs ansi" style="display:block;">0.0 ± 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sin(x)/cos(x) - tan(x) # They are equal within numerical accuracy</code><code class="nohighlight hljs ansi" style="display:block;">-2.220446049250313e-16 ± 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = -5.9 ± 0.2;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; beta(x, y) - gamma(x)*gamma(y)/gamma(x + y)</code><code class="nohighlight hljs ansi" style="display:block;">2.8e-14 ± 4.0e-14</code></pre><p>You will get similar results for a variable that is a function of an already existing <code>Measurement</code> object:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 8.4 ± 0.7;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = 2x;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (x + x) - u</code><code class="nohighlight hljs ansi" style="display:block;">0.0 ± 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u/2x</code><code class="nohighlight hljs ansi" style="display:block;">1.0 ± 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u^3 - 8x^3</code><code class="nohighlight hljs ansi" style="display:block;">0.0 ± 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cos(x)^2 - (1 + cos(u))/2</code><code class="nohighlight hljs ansi" style="display:block;">0.0 ± 0.0</code></pre><p>A variable that has the same nominal value and uncertainty as <code>u</code> above but is not functionally correlated with <code>x</code> will give different outcomes:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 8.4 ± 0.7;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = 16.8 ± 1.4;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (x + x) - v</code><code class="nohighlight hljs ansi" style="display:block;">0.0 ± 2.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v / 2x</code><code class="nohighlight hljs ansi" style="display:block;">1.0 ± 0.12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v^3 - 8x^3</code><code class="nohighlight hljs ansi" style="display:block;">0.0 ± 1700.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cos(x)^2 - (1 + cos(v))/2</code><code class="nohighlight hljs ansi" style="display:block;">0.0 ± 0.88</code></pre><h2 id="@uncertain-Macro"><a class="docs-heading-anchor" href="#@uncertain-Macro"><code>@uncertain</code> Macro</a><a id="@uncertain-Macro-1"></a><a class="docs-heading-anchor-permalink" href="#@uncertain-Macro" title="Permalink"></a></h2><p>Macro <a href="../usage/#Measurements.@uncertain"><code>@uncertain</code></a> can be used to propagate uncertainty in arbitrary real or complex functions of real arguments, including functions not natively supported by this package.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, SpecialFunctions</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @uncertain (x -&gt; complex(zeta(x), exp(eta(x)^2)))(2 ± 0.13)</code><code class="nohighlight hljs ansi" style="display:block;">(1.64 ± 0.12) + (1.967 ± 0.043)im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @uncertain log(9.4 ± 1.3, 58.8 ± 3.7)</code><code class="nohighlight hljs ansi" style="display:block;">1.82 ± 0.12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; log(9.4 ± 1.3, 58.8 ± 3.7) # Exact result</code><code class="nohighlight hljs ansi" style="display:block;">1.82 ± 0.12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @uncertain atan(10, 13.5 ± 0.8)</code><code class="nohighlight hljs ansi" style="display:block;">0.638 ± 0.028</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atan(10, 13.5 ± 0.8) # Exact result</code><code class="nohighlight hljs ansi" style="display:block;">0.638 ± 0.028</code></pre><p>You usually do not need to define a wrapping function before using it.  In the case where you have to define a function, like in the first line of previous examples, <a href="https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions-1">anonymous functions</a> allow you to do it in a very concise way.</p><p>The macro works with functions calling C/Fortran functions as well. For example, <a href="https://github.com/giordano/Cuba.jl">Cuba.jl</a> package performs numerical integration by wrapping the C <a href="http://www.feynarts.de/cuba/">Cuba</a> library. You can define a function to numerically compute with <code>Cuba.jl</code> the integral defining the <a href="https://en.wikipedia.org/wiki/Error_function">error function</a> and pass it to <code>@uncertain</code> macro. Compare the result with that of the <code>erf</code> function, natively supported in <code>Measurements.jl</code> package</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, Cuba, SpecialFunctions</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cubaerf(x::Real) =
           2x/sqrt(pi)*cuhre((t, f) -&gt; f[1] = exp(-abs2(t[1]*x)))[1][1]</code><code class="nohighlight hljs ansi" style="display:block;">cubaerf (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @uncertain cubaerf(0.5 ± 0.01)</code><code class="nohighlight hljs ansi" style="display:block;">0.5205 ± 0.0088</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; erf(0.5 ± 0.01) # Exact result</code><code class="nohighlight hljs ansi" style="display:block;">0.5205 ± 0.0088</code></pre><p>Also here you can use an anonymous function instead of defining the <code>cubaerf</code> function, do it as an exercise. Remember that if you want to numerically integrate a function that returns a <code>Measurement</code> object you can use <code>QuadGK.jl</code> package, which is written purely in Julia and in addition allows you to set <code>Measurement</code> objects as endpoints, see below.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Note that the argument of <code>@uncertain</code> macro must be a function call. Thus,</p><pre><code class="language-julia hljs">julia&gt; using Measurements, SpecialFunctions

julia&gt; @uncertain zeta(13.4 ± 0.8) + eta(8.51 ± 0.67)
ERROR: MethodError: no method matching zeta(::Measurement{Float64})
[...]</code></pre><p>will not work because here the outermost function is <code>+</code>, whose arguments are <code>zeta(13.4 ± 0.8)</code> and <code>eta(8.51 ± 0.67)</code>, that however cannot be calculated. You can use the <code>@uncertain</code> macro on each function separately:</p><pre><code class="language-julia-repl hljs">julia&gt; using Measurements, SpecialFunctions

julia&gt; @uncertain(zeta(13.4 ± 0.8)) +  @uncertain(eta(8.51 ± 0.67))
1.9974 ± 0.0012</code></pre><p>In addition, the function must be differentiable in all its arguments. For example, the polygamma function of order <span>$m$</span>, <code>polygamma(m, x)</code>, is the <span>$m+1$</span>-th derivative of the logarithm of gamma function, and is not differentiable in the first argument, because the first argument must be an integer. You can easily work around this limitation by wrapping the function in a single-argument function:</p><pre><code class="language-julia-repl hljs">julia&gt; using Measurements, SpecialFunctions

julia&gt; @uncertain (x -&gt; polygamma(0, x))(4.8 ± 0.2)
1.461 ± 0.046

julia&gt; digamma(4.8 ± 0.2)   # Exact result
1.461 ± 0.046</code></pre></div></div><h2 id="Complex-Measurements"><a class="docs-heading-anchor" href="#Complex-Measurements">Complex Measurements</a><a id="Complex-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-Measurements" title="Permalink"></a></h2><p>Here are a few examples about uncertainty propagation of complex-valued measurements.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = complex(32.7 ± 1.1, -3.1 ± 0.2);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = complex(7.6 ± 0.9, 53.2 ± 3.4);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2u + v</code><code class="nohighlight hljs ansi" style="display:block;">(73.0 ± 2.4) + (47.0 ± 3.4)im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sqrt(u * v)</code><code class="nohighlight hljs ansi" style="display:block;">(33.0 ± 1.1) + (26.0 ± 1.1)im</code></pre><p>You can also verify the <a href="https://en.wikipedia.org/wiki/Euler%27s_formula">Euler&#39;s formula</a></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = complex(32.7 ± 1.1, -3.1 ± 0.2);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cis(u)</code><code class="nohighlight hljs ansi" style="display:block;">(6.3 ± 23.0) + (21.3 ± 8.1)im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cos(u) + sin(u)*im</code><code class="nohighlight hljs ansi" style="display:block;">(6.3 ± 23.0) + (21.3 ± 8.1)im</code></pre><h2 id="Missing-Measurements"><a class="docs-heading-anchor" href="#Missing-Measurements">Missing Measurements</a><a id="Missing-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-Measurements" title="Permalink"></a></h2><p><code>Measurement</code> objects are poisoned by <a href="https://docs.julialang.org/en/v1/manual/missing/"><code>missing</code> values</a> as expected:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = -34.62 ± 0.93</code><code class="nohighlight hljs ansi" style="display:block;">-34.62 ± 0.93</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = missing ± 1.5</code><code class="nohighlight hljs ansi" style="display:block;">missing</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x ^ 2 / y</code><code class="nohighlight hljs ansi" style="display:block;">missing</code></pre><h2 id="Arbitrary-Precision-Calculations"><a class="docs-heading-anchor" href="#Arbitrary-Precision-Calculations">Arbitrary Precision Calculations</a><a id="Arbitrary-Precision-Calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Arbitrary-Precision-Calculations" title="Permalink"></a></h2><p>If you performed an exceptionally good experiment that gave you extremely precise results (that is, with very low relative error), you may want to use <a href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Arbitrary-Precision-Arithmetic-1">arbitrary precision</a> (or multiple precision) calculations, in order not to loose significance of the experimental results. Luckily, Julia natively supports this type of arithmetic and so <code>Measurements.jl</code> does. You only have to create <code>Measurement</code> objects with nominal value and uncertainty of type <code>BigFloat</code>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>As explained in the <a href="https://docs.julialang.org/en/v1/base/numbers/#BigFloats-and-BigInts-1">Julia documentation</a>, it is better to use <code>BigFloat(&quot;12.34&quot;)</code>, rather than <code>BigFloat(12.34)</code>. See examples below.</p></div></div><p>For example, you want to measure a quantity that is the product of two observables <span>$a$</span> and <span>$b$</span>, and the expected value of the product is <span>$12.00000007$</span>. You measure <span>$a = 3.00000001 \pm (1\times 10^{-17})$</span> and <span>$b = 4.0000000100000001 \pm (1\times 10^{-17})$</span> and want to compute the standard score of the product with <a href="../usage/#Measurements.stdscore"><code>stdscore</code></a>. Using the ability of <code>Measurements.jl</code> to perform arbitrary precision calculations you discover that</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = BigFloat(&quot;3.00000001&quot;) ± BigFloat(&quot;1e-17&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = BigFloat(&quot;4.0000000100000001&quot;) ± BigFloat(&quot;1e-17&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; stdscore(a * b, BigFloat(&quot;12.00000007&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">7.999999997599999878080000420160000093695993825308195353920411656927305928530607</code></pre><p>the measurement significantly differs from the expected value and you make a great discovery. Instead, if you used double precision accuracy, you would have wrongly found that your measurement is consistent with the expected value:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; stdscore((3.00000001 ± 1e-17)*(4.0000000100000001 ± 1e-17), 12.00000007)</code><code class="nohighlight hljs ansi" style="display:block;">0.0</code></pre><p>and you would have missed an important prize due to the use of an incorrect arithmetic.</p><p>Of course, you can perform any mathematical operation supported in <code>Measurements.jl</code> using arbitrary precision arithmetic:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = BigFloat(&quot;3.00000001&quot;) ± BigFloat(&quot;1e-17&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = BigFloat(&quot;4.0000000100000001&quot;) ± BigFloat(&quot;1e-17&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hypot(a, b)</code><code class="nohighlight hljs ansi" style="display:block;">5.000000014000000080000000000000000000000000000000000000000000000000000000000013 ± 9.999999999999999999999999999999999999999999999999999999999999999999999999999967e-18</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; log(2a) ^ b</code><code class="nohighlight hljs ansi" style="display:block;">10.30668110995484998100000000000000000000000000000000000000000000000000000000005 ± 9.699999999999999999999999999999999999999999999999999999999999999999999999999966e-17</code></pre><h2 id="Operations-with-Arrays-and-Linear-Algebra"><a class="docs-heading-anchor" href="#Operations-with-Arrays-and-Linear-Algebra">Operations with Arrays and Linear Algebra</a><a id="Operations-with-Arrays-and-Linear-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-with-Arrays-and-Linear-Algebra" title="Permalink"></a></h2><p>You can create arrays of <code>Measurement</code> objects and perform mathematical operations on them in the most natural way possible:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1.03 ± 0.14, 2.88 ± 0.35, 5.46 ± 0.97]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Measurement{Float64}}:
 1.03 ± 0.14
 2.88 ± 0.35
 5.46 ± 0.97</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = [0.92 ± 0.11, 3.14 ± 0.42, 4.67 ± 0.58]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Measurement{Float64}}:
 0.92 ± 0.11
 3.14 ± 0.42
 4.67 ± 0.58</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; exp.(sqrt.(B)) .- log.(A)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Measurement{Float64}}:
 2.58 ± 0.2
 4.82 ± 0.71
  7.0 ± 1.2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @. cos(A) ^ 2 + sin(A) ^ 2</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Measurement{Float64}}:
 1.0 ± 0.0
 1.0 ± 0.0
 1.0 ± 0.0</code></pre><p>If you originally have separate arrays of values and uncertainties, you can create an array of <code>Measurement</code> objects using <code>measurement</code> or <code>±</code> with the <a href="https://docs.julialang.org/en/v1/manual/functions/#man-vectorized-1">dot syntax</a> for vectorizing functions:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, Statistics</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; C = measurement.([174.9, 253.8, 626.3], [12.2, 19.4, 38.5])</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Measurement{Float64}}:
 175.0 ± 12.0
 254.0 ± 19.0
 626.0 ± 38.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(C)</code><code class="nohighlight hljs ansi" style="display:block;">1055.0 ± 45.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = [549.4, 672.3, 528.5] .± [7.4, 9.6, 5.2]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Measurement{Float64}}:
 549.4 ± 7.4
 672.3 ± 9.6
 528.5 ± 5.2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mean(D)</code><code class="nohighlight hljs ansi" style="display:block;">583.4 ± 4.4</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p><code>prod</code> and <code>sum</code> (and <code>mean</code>, which relies on <code>sum</code>) functions work out-of-the-box with any iterable of <code>Measurement</code> objects, like arrays or tuples. However, these functions have faster methods (quadratic in the number of elements) when operating on an array of <code>Measurement</code> s than on a tuple (in this case the computational complexity is cubic in the number of elements), so you should use an array if performance is crucial for you, in particular for large collections of measurements.</p></div></div><p>Some <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">linear algebra</a> functions work out-of-the-box, without defining specific methods for them. For example, you can solve linear systems, do matrix multiplication and dot product between vectors, find inverse, determinant, and trace of a matrix, do LU and QR factorization, etc. Additional linear algebra methods (<code>eigvals</code>, <code>cholesky</code>,  etc.) are provided by <a href="https://github.com/JuliaLinearAlgebra/GenericLinearAlgebra.jl">GenericLinearAlgebra.jl</a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, LinearAlgebra</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [(14 ± 0.1) (23 ± 0.2); (-12 ± 0.3) (24 ± 0.4)]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Measurement{Float64}}:
  14.0±0.1  23.0±0.2
 -12.0±0.3  24.0±0.4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = [(7 ± 0.5), (-13 ± 0.6)]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Measurement{Float64}}:
   7.0 ± 0.5
 -13.0 ± 0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = A \ b</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Measurement{Float64}}:
 0.763 ± 0.031
 -0.16 ± 0.018</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A * x ≈ b</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dot(x, b)</code><code class="nohighlight hljs ansi" style="display:block;">7.42 ± 0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; det(A)</code><code class="nohighlight hljs ansi" style="display:block;">612.0 ± 9.5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tr(A)</code><code class="nohighlight hljs ansi" style="display:block;">38.0 ± 0.41</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A * inv(A) ≈ Matrix{eltype(A)}(I, size(A))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; lu(A)</code><code class="nohighlight hljs ansi" style="display:block;">LinearAlgebra.LU{Measurement{Float64}, Matrix{Measurement{Float64}}}
L factor:
2×2 Matrix{Measurement{Float64}}:
    1.0±0.0    0.0±0.0
 -0.857±0.022  1.0±0.0
U factor:
2×2 Matrix{Measurement{Float64}}:
 14.0±0.1   23.0±0.2
  0.0±0.0  43.71±0.67</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; qr(A)</code><code class="nohighlight hljs ansi" style="display:block;">LinearAlgebra.QR{Measurement{Float64}, Matrix{Measurement{Float64}}}
Q factor:
2×2 LinearAlgebra.QRPackedQ{Measurement{Float64}, Matrix{Measurement{Float64}}}:
 -0.7593±0.0084  0.6508±0.0098
  0.6508±0.0098  0.7593±0.0084
R factor:
2×2 Matrix{Measurement{Float64}}:
 -18.44±0.21  -1.84±0.52
    0.0±0.0   33.19±0.33</code></pre><h2 id="Derivative,-Gradient-and-Uncertainty-Components"><a class="docs-heading-anchor" href="#Derivative,-Gradient-and-Uncertainty-Components">Derivative, Gradient and Uncertainty Components</a><a id="Derivative,-Gradient-and-Uncertainty-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative,-Gradient-and-Uncertainty-Components" title="Permalink"></a></h2><p>In order to propagate the uncertainties, <code>Measurements.jl</code> keeps track of the partial derivative of an expression with respect to all independent measurements from which the expression comes. The package provides a convenient function, <a href="../usage/#Measurements.derivative"><code>Measurements.derivative</code></a>, that returns the partial derivative of an expression with respect to independent measurements. Its vectorized version can be used to compute the gradient of an expression with respect to multiple independent measurements.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 98.1 ± 12.7</code><code class="nohighlight hljs ansi" style="display:block;">98.0 ± 13.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = 105.4 ± 25.6</code><code class="nohighlight hljs ansi" style="display:block;">105.0 ± 26.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; z = 78.3 ± 14.1</code><code class="nohighlight hljs ansi" style="display:block;">78.0 ± 14.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Measurements.derivative(2x - 4y, x)</code><code class="nohighlight hljs ansi" style="display:block;">2.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Measurements.derivative(2x - 4y, y)</code><code class="nohighlight hljs ansi" style="display:block;">-4.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Measurements.derivative.(log1p(x) + y^2 - cos(x/y), [x, y, z])</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
   0.017700515090289737
 210.7929173496422
   0.0</code></pre><p>The last result shows that the expression does not depend on <code>z</code>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The vectorized version of <code>Measurements.derivative</code> is useful in order to discover which variable contributes most to the total uncertainty of a given expression, if you want to minimize it. This can be calculated as the <a href="https://en.wikipedia.org/wiki/Hadamard_product_%28matrices%29">Hadamard (element-wise) product</a> between the gradient of the expression with respect to the set of variables and the vector of uncertainties of the same variables in the same order. For example:</p><pre><code class="language-julia hljs">julia&gt; w = y^(3//4)*log(y) + 3x - cos(y/x)
447.0410543780643 ± 52.41813324207829

julia&gt; abs.(Measurements.derivative.(w, [x, y]) .* Measurements.uncertainty.([x, y]))
2-element Array{Float64,1}:
 37.9777
 36.1297</code></pre><p>In this case, the <code>x</code> variable contributes most to the uncertainty of <code>w</code>. In addition, note that the <a href="https://en.wikipedia.org/wiki/Euclidean_norm">Euclidean norm</a> of the Hadamard product above is exactly the total uncertainty of the expression:</p><pre><code class="language-julia hljs">julia&gt; vecnorm(Measurements.derivative.(w, [x, y]) .* Measurements.uncertainty.([x, y]))
52.41813324207829</code></pre><p>The <a href="../usage/#Measurements.uncertainty_components"><code>Measurements.uncertainty_components</code></a> function simplifies calculation of all uncertainty components of a derived quantity:</p><pre><code class="language-julia hljs">julia&gt; Measurements.uncertainty_components(w)
Dict{Tuple{Float64,Float64,Float64},Float64} with 2 entries:
  (98.1, 12.7, 0.303638)  =&gt; 37.9777
  (105.4, 25.6, 0.465695) =&gt; 36.1297

julia&gt; norm(collect(values(Measurements.uncertainty_components(w))))
52.41813324207829</code></pre></div></div><h2 id="stdscore-Function"><a class="docs-heading-anchor" href="#stdscore-Function"><code>stdscore</code> Function</a><a id="stdscore-Function-1"></a><a class="docs-heading-anchor-permalink" href="#stdscore-Function" title="Permalink"></a></h2><p>You can get the distance in number of standard deviations between a measurement and its expected value (not a <code>Measurement</code>) using <a href="../usage/#Measurements.stdscore"><code>stdscore</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; stdscore(1.3 ± 0.12, 1)</code><code class="nohighlight hljs ansi" style="display:block;">2.5000000000000004</code></pre><p>You can use the same function also to test the consistency of two measurements by computing the standard score between their difference and zero. This is what <a href="../usage/#Measurements.stdscore"><code>stdscore</code></a> does when both arguments are <code>Measurement</code> objects:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; stdscore((4.7 ± 0.58) - (5 ± 0.01), 0)</code><code class="nohighlight hljs ansi" style="display:block;">-0.5171645175253433</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; stdscore(4.7 ± 0.58, 5 ± 0.01)</code><code class="nohighlight hljs ansi" style="display:block;">-0.5171645175253433</code></pre><h2 id="weightedmean-Function"><a class="docs-heading-anchor" href="#weightedmean-Function"><code>weightedmean</code> Function</a><a id="weightedmean-Function-1"></a><a class="docs-heading-anchor-permalink" href="#weightedmean-Function" title="Permalink"></a></h2><p>Calculate the weighted and arithmetic means of your set of measurements with <a href="../usage/#Measurements.weightedmean"><code>weightedmean</code></a> and <code>mean</code> respectively:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, Statistics</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; weightedmean((3.1±0.32, 3.2±0.38, 3.5±0.61, 3.8±0.25))</code><code class="nohighlight hljs ansi" style="display:block;">3.47 ± 0.17</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mean((3.1±0.32, 3.2±0.38, 3.5±0.61, 3.8±0.25))</code><code class="nohighlight hljs ansi" style="display:block;">3.4 ± 0.21</code></pre><h2 id="Measurements.value-and-Measurements.uncertainty-Functions"><a class="docs-heading-anchor" href="#Measurements.value-and-Measurements.uncertainty-Functions"><code>Measurements.value</code> and <code>Measurements.uncertainty</code> Functions</a><a id="Measurements.value-and-Measurements.uncertainty-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Measurements.value-and-Measurements.uncertainty-Functions" title="Permalink"></a></h2><p>Use <a href="../usage/#Measurements.value"><code>Measurements.value</code></a> and <a href="../usage/#Measurements.uncertainty"><code>Measurements.uncertainty</code></a> to get the values and uncertainties of measurements. They work with real and complex measurements, scalars or arrays:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Measurements.value(94.5 ± 1.6)</code><code class="nohighlight hljs ansi" style="display:block;">94.5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Measurements.uncertainty(94.5 ± 1.6)</code><code class="nohighlight hljs ansi" style="display:block;">1.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Measurements.value.([complex(87.3 ± 2.9, 64.3 ± 3.0), complex(55.1 ± 2.8, -19.1 ± 4.6)])</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ComplexF64}:
 87.3 + 64.3im
 55.1 - 19.1im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Measurements.uncertainty.([complex(87.3 ± 2.9, 64.3 ± 3.0), complex(55.1 ± 2.8, -19.1 ± 4.6)])</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ComplexF64}:
 2.9 + 3.0im
 2.8 + 4.6im</code></pre><h2 id="Interplay-with-Third-Party-Packages"><a class="docs-heading-anchor" href="#Interplay-with-Third-Party-Packages">Interplay with Third-Party Packages</a><a id="Interplay-with-Third-Party-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Interplay-with-Third-Party-Packages" title="Permalink"></a></h2><p><code>Measurements.jl</code> works out-of-the-box with any function taking arguments no more specific than <code>AbstractFloat</code>. This makes this library particularly suitable for cooperating with well-designed third-party packages in order to perform complicated calculations always accurately taking care of uncertainties and their correlations, with no effort for the developers nor users.</p><p>The following sections present a sample of packages that are known to work with <code>Measurements.jl</code>, but many others will interplay with this package as well as them.</p><h3 id="Numerical-Integration-with-QuadGK.jl"><a class="docs-heading-anchor" href="#Numerical-Integration-with-QuadGK.jl">Numerical Integration with <code>QuadGK.jl</code></a><a id="Numerical-Integration-with-QuadGK.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Integration-with-QuadGK.jl" title="Permalink"></a></h3><p>The powerful integration routine <code>quadgk</code> from <code>QuadGK.jl</code> package is smart enough to support out-of-the-box integrand functions that return arbitrary types, including <code>Measurement</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, QuadGK</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 4.71 ± 0.01;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; quadgk(x -&gt; exp(x / a), 1, 7)[1]</code><code class="nohighlight hljs ansi" style="display:block;">14.995 ± 0.031</code></pre><p><code>Measurements.jl</code> pushes the capabilities of <code>quadgk</code> further by supporting also <code>Measurement</code> objects as endpoints:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, QuadGK</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; quadgk(cos, 1.19 ± 0.02, 8.37 ± 0.05)[1]</code><code class="nohighlight hljs ansi" style="display:block;">-0.059 ± 0.026</code></pre><p>Compare this with the expected result:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, QuadGK</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sin(8.37 ± 0.05) - sin(1.19 ± 0.02)</code><code class="nohighlight hljs ansi" style="display:block;">-0.059 ± 0.026</code></pre><p>Also with <code>quadgk</code> correlation is properly taken into account:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, QuadGK</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 6.42 ± 0.03</code><code class="nohighlight hljs ansi" style="display:block;">6.42 ± 0.03</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; quadgk(sin, -a, a)</code><code class="nohighlight hljs ansi" style="display:block;">(2.484178227707412e-17 ± 0.0, 0.0)</code></pre><p>If instead the two endpoints have, by chance, the same nominal value and uncertainty but are not correlated:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, QuadGK</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; quadgk(sin, -6.42 ± 0.03, 6.42 ± 0.03)</code><code class="nohighlight hljs ansi" style="display:block;">(2.5e-17 ± 0.0058, 0.0)</code></pre><h3 id="Numerical-and-Automatic-Differentiation"><a class="docs-heading-anchor" href="#Numerical-and-Automatic-Differentiation">Numerical and Automatic Differentiation</a><a id="Numerical-and-Automatic-Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-and-Automatic-Differentiation" title="Permalink"></a></h3><p>With <a href="https://github.com/JuliaMath/Calculus.jl">Calculus.jl</a> package it is possible to perform numerical differentiation using finite differencing. You can pass in to the <code>Calculus.derivative</code> function both functions returning <code>Measurement</code> objects and a <code>Measurement</code> as the point in which to calculate the derivative.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, Calculus</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = -45.7 ± 1.6</code><code class="nohighlight hljs ansi" style="display:block;">-45.7 ± 1.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = 36.5 ± 6.0</code><code class="nohighlight hljs ansi" style="display:block;">36.5 ± 6.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Calculus.derivative(exp, a) ≈ exp(a)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Calculus.derivative(cos, b) ≈ -sin(b)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Calculus.derivative(t -&gt; log(-t * b)^2, a) ≈ 2log(-a * b)/a</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Other packages provide <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a> methods. Here is an example with <a href="https://github.com/denizyuret/AutoGrad.jl">AutoGrad.jl</a>, just one of the packages available:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, AutoGrad</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = -45.7 ± 1.6</code><code class="nohighlight hljs ansi" style="display:block;">-45.7 ± 1.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = 36.5 ± 6.0</code><code class="nohighlight hljs ansi" style="display:block;">36.5 ± 6.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; grad(exp)(a) ≈ exp(a)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; grad(cos)(b) ≈ -sin(b)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; grad(t -&gt; log(-t * b)^2)(a) ≈ 2log(-a * b)/a</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>However remember that you can always use <a href="../usage/#Measurements.derivative"><code>Measurements.derivative</code></a> to compute the value (without uncertainty) of the derivative of a <code>Measurement</code> object.</p><h3 id="Use-with-Unitful.jl"><a class="docs-heading-anchor" href="#Use-with-Unitful.jl">Use with <code>Unitful.jl</code></a><a id="Use-with-Unitful.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Use-with-Unitful.jl" title="Permalink"></a></h3><p>You can use <code>Measurements.jl</code> in combination with <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a> in order to perform calculations involving physical measurements, i.e.  numbers with uncertainty and physical unit.  You only have to use the <code>Measurement</code> object as the value of the <code>Quantity</code> object. Here are a few examples.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Measurements, Unitful</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hypot((3 ± 1)*u&quot;m&quot;, (4 ± 2)*u&quot;m&quot;) # Pythagorean theorem</code><code class="nohighlight hljs ansi" style="display:block;">5.0 ± 1.7 m</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (50 ± 1)*u&quot;Ω&quot; * (13 ± 2.4)*1e-2*u&quot;A&quot; # Ohm&#39;s Law</code><code class="nohighlight hljs ansi" style="display:block;">6.5 ± 1.2 A Ω</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2pi*sqrt((5.4 ± 0.3)*u&quot;m&quot; / ((9.81 ± 0.01)*u&quot;m/s^2&quot;)) # Pendulum&#39;s period</code><code class="nohighlight hljs ansi" style="display:block;">4.66 ± 0.13 s</code></pre><h2 id="Integration-with-Plots.jl"><a class="docs-heading-anchor" href="#Integration-with-Plots.jl">Integration with <code>Plots.jl</code></a><a id="Integration-with-Plots.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-with-Plots.jl" title="Permalink"></a></h2><p><code>Measurements.jl</code> provides plot recipes for the Julia graphic framework <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>. Arguments to <code>plot</code> function that have <code>Measurement</code> type will be automatically represented with errorbars.</p><pre><code class="language-julia hljs">julia&gt; using Measurements, Plots

julia&gt; plot(sin, [x ± 0.1 for x in 1:0.2:10], size = (1200, 800))</code></pre><p><img src="../plot-example.png" alt="image"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usage/">« Usage</a><a class="docs-footer-nextpage" href="../performance/">Performance »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Wednesday 18 May 2022 19:18">Wednesday 18 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
