<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Measurements</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Measurements</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Measurements-from-Strings"><span>Measurements from Strings</span></a></li><li><a class="tocitem" href="#Correlation-Between-Variables"><span>Correlation Between Variables</span></a></li><li><a class="tocitem" href="#@uncertain-Macro"><span><code>@uncertain</code> Macro</span></a></li><li><a class="tocitem" href="#Complex-Measurements"><span>Complex Measurements</span></a></li><li><a class="tocitem" href="#Missing-Measurements"><span>Missing Measurements</span></a></li><li><a class="tocitem" href="#Arbitrary-Precision-Calculations"><span>Arbitrary Precision Calculations</span></a></li><li><a class="tocitem" href="#Operations-with-Arrays-and-Linear-Algebra"><span>Operations with Arrays and Linear Algebra</span></a></li><li><a class="tocitem" href="#Derivative,-Gradient-and-Uncertainty-Components"><span>Derivative, Gradient and Uncertainty Components</span></a></li><li><a class="tocitem" href="#stdscore-Function"><span><code>stdscore</code> Function</span></a></li><li><a class="tocitem" href="#weightedmean-Function"><span><code>weightedmean</code> Function</span></a></li><li><a class="tocitem" href="#Measurements.value-and-Measurements.uncertainty-Functions"><span><code>Measurements.value</code> and <code>Measurements.uncertainty</code> Functions</span></a></li><li><a class="tocitem" href="#Interplay-with-Third-Party-Packages"><span>Interplay with Third-Party Packages</span></a></li><li><a class="tocitem" href="#Integration-with-Plots.jl"><span>Integration with <code>Plots.jl</code></span></a></li></ul></li><li><a class="tocitem" href="../performance/">Performance</a></li><li><a class="tocitem" href="../todo/">Development</a></li><li><a class="tocitem" href="../appendix/">Appendix</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPhysics/Measurements.jl/blob/master/docs/src/examples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>These are some basic examples of use of the package:</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; a = measurement(4.5, 0.1)
4.5 ± 0.1

julia&gt; b = 3.8 ± 0.4
3.8 ± 0.4

julia&gt; 2a + b
12.8 ± 0.45

julia&gt; a - 1.2b
-0.06 ± 0.49

julia&gt; l = measurement(0.936, 1e-3);

julia&gt; T = 1.942 ± 4e-3;

julia&gt; g = 4pi^2*l/T^2
9.798 ± 0.042

julia&gt; c = measurement(4)
4.0 ± 0.0

julia&gt; a*c
18.0 ± 0.4

julia&gt; sind(94 ± 1.2)
0.9976 ± 0.0015

julia&gt; x = 5.48 ± 0.67;

julia&gt; y = 9.36 ± 1.02;

julia&gt; log(2x^2 - 3.4y)
3.34 ± 0.53

julia&gt; atan(y, x)
1.041 ± 0.071</code></pre><h2 id="Measurements-from-Strings"><a class="docs-heading-anchor" href="#Measurements-from-Strings">Measurements from Strings</a><a id="Measurements-from-Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Measurements-from-Strings" title="Permalink"></a></h2><p>You can construct <code>Measurement{Float64}</code> objects from strings. Within parentheses there is the uncertainty referred to the corresponding last digits.</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; measurement(&quot;-12.34(56)&quot;)
-12.34 ± 0.56

julia&gt; measurement(&quot;+1234(56)e-2&quot;)
12.34 ± 0.56

julia&gt; measurement(&quot;123.4e-1 +- 0.056e1&quot;)
12.34 ± 0.56

julia&gt; measurement(&quot;(-1.234 ± 0.056)e1&quot;)
-12.34 ± 0.56

julia&gt; measurement(&quot;1234e-2 +/- 0.56e0&quot;)
12.34 ± 0.56

julia&gt; measurement(&quot;-1234e-2&quot;)
-12.34 ± 0.0</code></pre><p>It is also possible to use <code>parse(Measurement{T}, string)</code> to parse the <code>string</code> as a <code>Measurement{T}</code>, with <code>T&lt;:AbstractFloat</code>. This has been tested with standard numeric floating types (<code>Float16</code>, <code>Float32</code>, <code>Float64</code>, and <code>BigFloat</code>).</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; parse(Measurement{Float16}, &quot;19.5 ± 2.8&quot;)
19.5 ± 2.8

julia&gt; parse(Measurement{Float32}, &quot;-7.6 ± 0.4&quot;)
-7.6 ± 0.4

julia&gt; parse(Measurement{Float64}, &quot;4 ± 1.3&quot;)
4.0 ± 1.3

julia&gt; parse(Measurement{BigFloat}, &quot;+5.1 ± 3.3&quot;)
5.099999999999999999999999999999999999999999999999999999999999999999999999999986 ± 3.299999999999999999999999999999999999999999999999999999999999999999999999999993</code></pre><h2 id="Correlation-Between-Variables"><a class="docs-heading-anchor" href="#Correlation-Between-Variables">Correlation Between Variables</a><a id="Correlation-Between-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Correlation-Between-Variables" title="Permalink"></a></h2><p>Here you can see examples of how functionally correlated variables are treated within the package:</p><pre><code class="language-julia-repl">julia&gt; using Measurements, SpecialFunctions

julia&gt; x = 8.4 ± 0.7
8.4 ± 0.7

julia&gt; x - x
0.0 ± 0.0

julia&gt; x/x
1.0 ± 0.0

julia&gt; x*x*x - x^3
0.0 ± 0.0

julia&gt; sin(x)/cos(x) - tan(x) # They are equal within numerical accuracy
-2.220446049250313e-16 ± 0.0

julia&gt; y = -5.9 ± 0.2;

julia&gt; beta(x, y) - gamma(x)*gamma(y)/gamma(x + y)
2.8e-14 ± 4.0e-14</code></pre><p>You will get similar results for a variable that is a function of an already existing <code>Measurement</code> object:</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; x = 8.4 ± 0.7;

julia&gt; u = 2x;

julia&gt; (x + x) - u
0.0 ± 0.0

julia&gt; u/2x
1.0 ± 0.0

julia&gt; u^3 - 8x^3
0.0 ± 0.0

julia&gt; cos(x)^2 - (1 + cos(u))/2
0.0 ± 0.0</code></pre><p>A variable that has the same nominal value and uncertainty as <code>u</code> above but is not functionally correlated with <code>x</code> will give different outcomes:</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; x = 8.4 ± 0.7;

julia&gt; v = 16.8 ± 1.4;

julia&gt; (x + x) - v
0.0 ± 2.0

julia&gt; v / 2x
1.0 ± 0.12

julia&gt; v^3 - 8x^3
0.0 ± 1700.0

julia&gt; cos(x)^2 - (1 + cos(v))/2
0.0 ± 0.88</code></pre><h2 id="@uncertain-Macro"><a class="docs-heading-anchor" href="#@uncertain-Macro"><code>@uncertain</code> Macro</a><a id="@uncertain-Macro-1"></a><a class="docs-heading-anchor-permalink" href="#@uncertain-Macro" title="Permalink"></a></h2><p>Macro <a href="../usage/#Measurements.@uncertain"><code>@uncertain</code></a> can be used to propagate uncertainty in arbitrary real or complex functions of real arguments, including functions not natively supported by this package.</p><pre><code class="language-julia-repl">julia&gt; using Measurements, SpecialFunctions

julia&gt; @uncertain (x -&gt; complex(zeta(x), exp(eta(x)^2)))(2 ± 0.13)
(1.64 ± 0.12) + (1.967 ± 0.043)im

julia&gt; @uncertain log(9.4 ± 1.3, 58.8 ± 3.7)
1.82 ± 0.12

julia&gt; log(9.4 ± 1.3, 58.8 ± 3.7) # Exact result
1.82 ± 0.12

julia&gt; @uncertain atan(10, 13.5 ± 0.8)
0.638 ± 0.028

julia&gt; atan(10, 13.5 ± 0.8) # Exact result
0.638 ± 0.028</code></pre><p>You usually do not need to define a wrapping function before using it.  In the case where you have to define a function, like in the first line of previous examples, <a href="https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions-1">anonymous functions</a> allow you to do it in a very concise way.</p><p>The macro works with functions calling C/Fortran functions as well. For example, <a href="https://github.com/giordano/Cuba.jl">Cuba.jl</a> package performs numerical integration by wrapping the C <a href="http://www.feynarts.de/cuba/">Cuba</a> library. You can define a function to numerically compute with <code>Cuba.jl</code> the integral defining the <a href="https://en.wikipedia.org/wiki/Error_function">error function</a> and pass it to <code>@uncertain</code> macro. Compare the result with that of the <code>erf</code> function, natively supported in <code>Measurements.jl</code> package</p><pre><code class="language-julia-repl">julia&gt; using Measurements, Cuba, SpecialFunctions

julia&gt; cubaerf(x::Real) =
           2x/sqrt(pi)*cuhre((t, f) -&gt; f[1] = exp(-abs2(t[1]*x)))[1][1]
cubaerf (generic function with 1 method)

julia&gt; @uncertain cubaerf(0.5 ± 0.01)
0.5205 ± 0.0088

julia&gt; erf(0.5 ± 0.01) # Exact result
0.5205 ± 0.0088</code></pre><p>Also here you can use an anonymous function instead of defining the <code>cubaerf</code> function, do it as an exercise. Remember that if you want to numerically integrate a function that returns a <code>Measurement</code> object you can use <code>QuadGK.jl</code> package, which is written purely in Julia and in addition allows you to set <code>Measurement</code> objects as endpoints, see below.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Note that the argument of <code>@uncertain</code> macro must be a function call. Thus,</p><pre><code class="language-julia">julia&gt; using Measurements, SpecialFunctions

julia&gt; @uncertain zeta(13.4 ± 0.8) + eta(8.51 ± 0.67)
ERROR: MethodError: no method matching zeta(::Measurement{Float64})
[...]</code></pre><p>will not work because here the outermost function is <code>+</code>, whose arguments are <code>zeta(13.4 ± 0.8)</code> and <code>eta(8.51 ± 0.67)</code>, that however cannot be calculated. You can use the <code>@uncertain</code> macro on each function separately:</p><pre><code class="language-julia-repl">julia&gt; using Measurements, SpecialFunctions

julia&gt; @uncertain(zeta(13.4 ± 0.8)) +  @uncertain(eta(8.51 ± 0.67))
1.9974 ± 0.0012</code></pre><p>In addition, the function must be differentiable in all its arguments. For example, the polygamma function of order <span>$m$</span>, <code>polygamma(m, x)</code>, is the <span>$m+1$</span>-th derivative of the logarithm of gamma function, and is not differentiable in the first argument, because the first argument must be an integer. You can easily work around this limitation by wrapping the function in a single-argument function:</p><pre><code class="language-julia-repl">julia&gt; using Measurements, SpecialFunctions

julia&gt; @uncertain (x -&gt; polygamma(0, x))(4.8 ± 0.2)
1.461 ± 0.046

julia&gt; digamma(4.8 ± 0.2)   # Exact result
1.461 ± 0.046</code></pre></div></div><h2 id="Complex-Measurements"><a class="docs-heading-anchor" href="#Complex-Measurements">Complex Measurements</a><a id="Complex-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-Measurements" title="Permalink"></a></h2><p>Here are a few examples about uncertainty propagation of complex-valued measurements.</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; u = complex(32.7 ± 1.1, -3.1 ± 0.2);

julia&gt; v = complex(7.6 ± 0.9, 53.2 ± 3.4);

julia&gt; 2u + v
(73.0 ± 2.4) + (47.0 ± 3.4)im

julia&gt; sqrt(u * v)
(33.0 ± 1.1) + (26.0 ± 1.1)im</code></pre><p>You can also verify the <a href="https://en.wikipedia.org/wiki/Euler%27s_formula">Euler&#39;s formula</a></p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; u = complex(32.7 ± 1.1, -3.1 ± 0.2);

julia&gt; cis(u)
(6.3 ± 23.0) + (21.3 ± 8.1)im

julia&gt; cos(u) + sin(u)*im
(6.3 ± 23.0) + (21.3 ± 8.1)im</code></pre><h2 id="Missing-Measurements"><a class="docs-heading-anchor" href="#Missing-Measurements">Missing Measurements</a><a id="Missing-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-Measurements" title="Permalink"></a></h2><p><code>Measurement</code> objects are poisoned by <a href="https://docs.julialang.org/en/v1/manual/missing/"><code>missing</code> values</a> as expected:</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; x = -34.62 ± 0.93
-34.62 ± 0.93

julia&gt; y = missing ± 1.5
missing

julia&gt; x ^ 2 / y
missing</code></pre><h2 id="Arbitrary-Precision-Calculations"><a class="docs-heading-anchor" href="#Arbitrary-Precision-Calculations">Arbitrary Precision Calculations</a><a id="Arbitrary-Precision-Calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Arbitrary-Precision-Calculations" title="Permalink"></a></h2><p>If you performed an exceptionally good experiment that gave you extremely precise results (that is, with very low relative error), you may want to use <a href="https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Arbitrary-Precision-Arithmetic-1">arbitrary precision</a> (or multiple precision) calculations, in order not to loose significance of the experimental results. Luckily, Julia natively supports this type of arithmetic and so <code>Measurements.jl</code> does. You only have to create <code>Measurement</code> objects with nominal value and uncertainty of type <code>BigFloat</code>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>As explained in the <a href="https://docs.julialang.org/en/v1/base/numbers/#BigFloats-and-BigInts-1">Julia documentation</a>, it is better to use <code>BigFloat(&quot;12.34&quot;)</code>, rather than <code>BigFloat(12.34)</code>. See examples below.</p></div></div><p>For example, you want to measure a quantity that is the product of two observables <span>$a$</span> and <span>$b$</span>, and the expected value of the product is <span>$12.00000007$</span>. You measure <span>$a = 3.00000001 \pm (1\times 10^{-17})$</span> and <span>$b = 4.0000000100000001 \pm (1\times 10^{-17})$</span> and want to compute the standard score of the product with <a href="../usage/#Measurements.stdscore"><code>stdscore</code></a>. Using the ability of <code>Measurements.jl</code> to perform arbitrary precision calculations you discover that</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; a = BigFloat(&quot;3.00000001&quot;) ± BigFloat(&quot;1e-17&quot;);

julia&gt; b = BigFloat(&quot;4.0000000100000001&quot;) ± BigFloat(&quot;1e-17&quot;);

julia&gt; stdscore(a * b, BigFloat(&quot;12.00000007&quot;))
7.999999997599999878080000420160000093695993825308195353920411656927305928530607</code></pre><p>the measurement significantly differs from the expected value and you make a great discovery. Instead, if you used double precision accuracy, you would have wrongly found that your measurement is consistent with the expected value:</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; stdscore((3.00000001 ± 1e-17)*(4.0000000100000001 ± 1e-17), 12.00000007)
0.0</code></pre><p>and you would have missed an important prize due to the use of an incorrect arithmetic.</p><p>Of course, you can perform any mathematical operation supported in <code>Measurements.jl</code> using arbitrary precision arithmetic:</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; a = BigFloat(&quot;3.00000001&quot;) ± BigFloat(&quot;1e-17&quot;);

julia&gt; b = BigFloat(&quot;4.0000000100000001&quot;) ± BigFloat(&quot;1e-17&quot;);

julia&gt; hypot(a, b)
5.000000014000000080000000000000000000000000000000000000000000000000000000000013 ± 9.999999999999999999999999999999999999999999999999999999999999999999999999999967e-18

julia&gt; log(2a) ^ b
10.30668110995484998100000000000000000000000000000000000000000000000000000000005 ± 9.699999999999999999999999999999999999999999999999999999999999999999999999999966e-17</code></pre><h2 id="Operations-with-Arrays-and-Linear-Algebra"><a class="docs-heading-anchor" href="#Operations-with-Arrays-and-Linear-Algebra">Operations with Arrays and Linear Algebra</a><a id="Operations-with-Arrays-and-Linear-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-with-Arrays-and-Linear-Algebra" title="Permalink"></a></h2><p>You can create arrays of <code>Measurement</code> objects and perform mathematical operations on them in the most natural way possible:</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; A = [1.03 ± 0.14, 2.88 ± 0.35, 5.46 ± 0.97]
3-element Vector{Measurement{Float64}}:
 1.03 ± 0.14
 2.88 ± 0.35
 5.46 ± 0.97

julia&gt; B = [0.92 ± 0.11, 3.14 ± 0.42, 4.67 ± 0.58]
3-element Vector{Measurement{Float64}}:
 0.92 ± 0.11
 3.14 ± 0.42
 4.67 ± 0.58

julia&gt; exp.(sqrt.(B)) .- log.(A)
3-element Vector{Measurement{Float64}}:
 2.58 ± 0.2
 4.82 ± 0.71
  7.0 ± 1.2

julia&gt; @. cos(A) ^ 2 + sin(A) ^ 2
3-element Vector{Measurement{Float64}}:
 1.0 ± 0.0
 1.0 ± 0.0
 1.0 ± 0.0</code></pre><p>If you originally have separate arrays of values and uncertainties, you can create an array of <code>Measurement</code> objects using <code>measurement</code> or <code>±</code> with the <a href="https://docs.julialang.org/en/v1/manual/functions/#man-vectorized-1">dot syntax</a> for vectorizing functions:</p><pre><code class="language-julia-repl">julia&gt; using Measurements, Statistics

julia&gt; C = measurement.([174.9, 253.8, 626.3], [12.2, 19.4, 38.5])
3-element Vector{Measurement{Float64}}:
 175.0 ± 12.0
 254.0 ± 19.0
 626.0 ± 38.0

julia&gt; sum(C)
1055.0 ± 45.0

julia&gt; D = [549.4, 672.3, 528.5] .± [7.4, 9.6, 5.2]
3-element Vector{Measurement{Float64}}:
 549.4 ± 7.4
 672.3 ± 9.6
 528.5 ± 5.2

julia&gt; mean(D)
583.4 ± 4.4</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p><code>prod</code> and <code>sum</code> (and <code>mean</code>, which relies on <code>sum</code>) functions work out-of-the-box with any iterable of <code>Measurement</code> objects, like arrays or tuples. However, these functions have faster methods (quadratic in the number of elements) when operating on an array of <code>Measurement</code> s than on a tuple (in this case the computational complexity is cubic in the number of elements), so you should use an array if performance is crucial for you, in particular for large collections of measurements.</p></div></div><p>Some <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">linear algebra</a> functions work out-of-the-box, without defining specific methods for them. For example, you can solve linear systems, do matrix multiplication and dot product between vectors, find inverse, determinant, and trace of a matrix, do LU and QR factorization, etc. Additional linear algebra methods (<code>eigvals</code>, <code>cholesky</code>,  etc.) are provided by <a href="https://github.com/JuliaLinearAlgebra/GenericLinearAlgebra.jl">GenericLinearAlgebra.jl</a>.</p><pre><code class="language-julia-repl">julia&gt; using Measurements, LinearAlgebra

julia&gt; A = [(14 ± 0.1) (23 ± 0.2); (-12 ± 0.3) (24 ± 0.4)]
2×2 Matrix{Measurement{Float64}}:
  14.0±0.1  23.0±0.2
 -12.0±0.3  24.0±0.4

julia&gt; b = [(7 ± 0.5), (-13 ± 0.6)]
2-element Vector{Measurement{Float64}}:
   7.0 ± 0.5
 -13.0 ± 0.6

julia&gt; x = A \ b
2-element Vector{Measurement{Float64}}:
 0.763 ± 0.031
 -0.16 ± 0.018

julia&gt; A * x ≈ b
true

julia&gt; dot(x, b)
7.42 ± 0.6

julia&gt; det(A)
612.0 ± 9.5

julia&gt; tr(A)
38.0 ± 0.41

julia&gt; A * inv(A) ≈ Matrix{eltype(A)}(I, size(A))
true

julia&gt; lu(A)
LinearAlgebra.LU{Measurement{Float64}, Matrix{Measurement{Float64}}}
L factor:
2×2 Matrix{Measurement{Float64}}:
    1.0±0.0    0.0±0.0
 -0.857±0.022  1.0±0.0
U factor:
2×2 Matrix{Measurement{Float64}}:
 14.0±0.1   23.0±0.2
  0.0±0.0  43.71±0.67

julia&gt; qr(A)
LinearAlgebra.QR{Measurement{Float64}, Matrix{Measurement{Float64}}}
Q factor:
2×2 LinearAlgebra.QRPackedQ{Measurement{Float64}, Matrix{Measurement{Float64}}}:
 -0.7593±0.0084  0.6508±0.0098
  0.6508±0.0098  0.7593±0.0084
R factor:
2×2 Matrix{Measurement{Float64}}:
 -18.44±0.21  -1.84±0.52
    0.0±0.0   33.19±0.33</code></pre><h2 id="Derivative,-Gradient-and-Uncertainty-Components"><a class="docs-heading-anchor" href="#Derivative,-Gradient-and-Uncertainty-Components">Derivative, Gradient and Uncertainty Components</a><a id="Derivative,-Gradient-and-Uncertainty-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Derivative,-Gradient-and-Uncertainty-Components" title="Permalink"></a></h2><p>In order to propagate the uncertainties, <code>Measurements.jl</code> keeps track of the partial derivative of an expression with respect to all independent measurements from which the expression comes. The package provides a convenient function, <a href="../usage/#Measurements.derivative"><code>Measurements.derivative</code></a>, that returns the partial derivative of an expression with respect to independent measurements. Its vectorized version can be used to compute the gradient of an expression with respect to multiple independent measurements.</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; x = 98.1 ± 12.7
98.0 ± 13.0

julia&gt; y = 105.4 ± 25.6
105.0 ± 26.0

julia&gt; z = 78.3 ± 14.1
78.0 ± 14.0

julia&gt; Measurements.derivative(2x - 4y, x)
2.0

julia&gt; Measurements.derivative(2x - 4y, y)
-4.0

julia&gt; Measurements.derivative.(log1p(x) + y^2 - cos(x/y), [x, y, z])
3-element Vector{Float64}:
   0.017700515090289737
 210.7929173496422
   0.0</code></pre><p>The last result shows that the expression does not depend on <code>z</code>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The vectorized version of <code>Measurements.derivative</code> is useful in order to discover which variable contributes most to the total uncertainty of a given expression, if you want to minimize it. This can be calculated as the <a href="https://en.wikipedia.org/wiki/Hadamard_product_%28matrices%29">Hadamard (element-wise) product</a> between the gradient of the expression with respect to the set of variables and the vector of uncertainties of the same variables in the same order. For example:</p><pre><code class="language-julia">julia&gt; w = y^(3//4)*log(y) + 3x - cos(y/x)
447.0410543780643 ± 52.41813324207829

julia&gt; abs.(Measurements.derivative.(w, [x, y]) .* Measurements.uncertainty.([x, y]))
2-element Array{Float64,1}:
 37.9777
 36.1297</code></pre><p>In this case, the <code>x</code> variable contributes most to the uncertainty of <code>w</code>. In addition, note that the <a href="https://en.wikipedia.org/wiki/Euclidean_norm">Euclidean norm</a> of the Hadamard product above is exactly the total uncertainty of the expression:</p><pre><code class="language-julia">julia&gt; vecnorm(Measurements.derivative.(w, [x, y]) .* Measurements.uncertainty.([x, y]))
52.41813324207829</code></pre><p>The <a href="../usage/#Measurements.uncertainty_components"><code>Measurements.uncertainty_components</code></a> function simplifies calculation of all uncertainty components of a derived quantity:</p><pre><code class="language-julia">julia&gt; Measurements.uncertainty_components(w)
Dict{Tuple{Float64,Float64,Float64},Float64} with 2 entries:
  (98.1, 12.7, 0.303638)  =&gt; 37.9777
  (105.4, 25.6, 0.465695) =&gt; 36.1297

julia&gt; norm(collect(values(Measurements.uncertainty_components(w))))
52.41813324207829</code></pre></div></div><h2 id="stdscore-Function"><a class="docs-heading-anchor" href="#stdscore-Function"><code>stdscore</code> Function</a><a id="stdscore-Function-1"></a><a class="docs-heading-anchor-permalink" href="#stdscore-Function" title="Permalink"></a></h2><p>You can get the distance in number of standard deviations between a measurement and its expected value (not a <code>Measurement</code>) using <a href="../usage/#Measurements.stdscore"><code>stdscore</code></a>:</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; stdscore(1.3 ± 0.12, 1)
2.5000000000000004</code></pre><p>You can use the same function also to test the consistency of two measurements by computing the standard score between their difference and zero. This is what <a href="../usage/#Measurements.stdscore"><code>stdscore</code></a> does when both arguments are <code>Measurement</code> objects:</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; stdscore((4.7 ± 0.58) - (5 ± 0.01), 0)
-0.5171645175253433

julia&gt; stdscore(4.7 ± 0.58, 5 ± 0.01)
-0.5171645175253433</code></pre><h2 id="weightedmean-Function"><a class="docs-heading-anchor" href="#weightedmean-Function"><code>weightedmean</code> Function</a><a id="weightedmean-Function-1"></a><a class="docs-heading-anchor-permalink" href="#weightedmean-Function" title="Permalink"></a></h2><p>Calculate the weighted and arithmetic means of your set of measurements with <a href="../usage/#Measurements.weightedmean"><code>weightedmean</code></a> and <code>mean</code> respectively:</p><pre><code class="language-julia-repl">julia&gt; using Measurements, Statistics

julia&gt; weightedmean((3.1±0.32, 3.2±0.38, 3.5±0.61, 3.8±0.25))
3.47 ± 0.17

julia&gt; mean((3.1±0.32, 3.2±0.38, 3.5±0.61, 3.8±0.25))
3.4 ± 0.21</code></pre><h2 id="Measurements.value-and-Measurements.uncertainty-Functions"><a class="docs-heading-anchor" href="#Measurements.value-and-Measurements.uncertainty-Functions"><code>Measurements.value</code> and <code>Measurements.uncertainty</code> Functions</a><a id="Measurements.value-and-Measurements.uncertainty-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Measurements.value-and-Measurements.uncertainty-Functions" title="Permalink"></a></h2><p>Use <a href="../usage/#Measurements.value"><code>Measurements.value</code></a> and <a href="../usage/#Measurements.uncertainty"><code>Measurements.uncertainty</code></a> to get the values and uncertainties of measurements. They work with real and complex measurements, scalars or arrays:</p><pre><code class="language-julia-repl">julia&gt; using Measurements

julia&gt; Measurements.value(94.5 ± 1.6)
94.5

julia&gt; Measurements.uncertainty(94.5 ± 1.6)
1.6

julia&gt; Measurements.value.([complex(87.3 ± 2.9, 64.3 ± 3.0), complex(55.1 ± 2.8, -19.1 ± 4.6)])
2-element Vector{ComplexF64}:
 87.3 + 64.3im
 55.1 - 19.1im

julia&gt; Measurements.uncertainty.([complex(87.3 ± 2.9, 64.3 ± 3.0), complex(55.1 ± 2.8, -19.1 ± 4.6)])
2-element Vector{ComplexF64}:
 2.9 + 3.0im
 2.8 + 4.6im</code></pre><h2 id="Interplay-with-Third-Party-Packages"><a class="docs-heading-anchor" href="#Interplay-with-Third-Party-Packages">Interplay with Third-Party Packages</a><a id="Interplay-with-Third-Party-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Interplay-with-Third-Party-Packages" title="Permalink"></a></h2><p><code>Measurements.jl</code> works out-of-the-box with any function taking arguments no more specific than <code>AbstractFloat</code>. This makes this library particularly suitable for cooperating with well-designed third-party packages in order to perform complicated calculations always accurately taking care of uncertainties and their correlations, with no effort for the developers nor users.</p><p>The following sections present a sample of packages that are known to work with <code>Measurements.jl</code>, but many others will interplay with this package as well as them.</p><h3 id="Numerical-Integration-with-QuadGK.jl"><a class="docs-heading-anchor" href="#Numerical-Integration-with-QuadGK.jl">Numerical Integration with <code>QuadGK.jl</code></a><a id="Numerical-Integration-with-QuadGK.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Integration-with-QuadGK.jl" title="Permalink"></a></h3><p>The powerful integration routine <code>quadgk</code> from <code>QuadGK.jl</code> package is smart enough to support out-of-the-box integrand functions that return arbitrary types, including <code>Measurement</code>:</p><pre><code class="language-julia-repl">julia&gt; using Measurements, QuadGK

julia&gt; a = 4.71 ± 0.01;

julia&gt; quadgk(x -&gt; exp(x / a), 1, 7)[1]
14.995 ± 0.031</code></pre><p><code>Measurements.jl</code> pushes the capabilities of <code>quadgk</code> further by supporting also <code>Measurement</code> objects as endpoints:</p><pre><code class="language-julia-repl">julia&gt; using Measurements, QuadGK

julia&gt; quadgk(cos, 1.19 ± 0.02, 8.37 ± 0.05)[1]
-0.059 ± 0.026</code></pre><p>Compare this with the expected result:</p><pre><code class="language-julia-repl">julia&gt; using Measurements, QuadGK

julia&gt; sin(8.37 ± 0.05) - sin(1.19 ± 0.02)
-0.059 ± 0.026</code></pre><p>Also with <code>quadgk</code> correlation is properly taken into account:</p><pre><code class="language-julia-repl">julia&gt; using Measurements, QuadGK

julia&gt; a = 6.42 ± 0.03
6.42 ± 0.03

julia&gt; quadgk(sin, -a, a)
(2.484178227707412e-17 ± 0.0, 0.0)</code></pre><p>If instead the two endpoints have, by chance, the same nominal value and uncertainty but are not correlated:</p><pre><code class="language-julia-repl">julia&gt; using Measurements, QuadGK

julia&gt; quadgk(sin, -6.42 ± 0.03, 6.42 ± 0.03)
(2.5e-17 ± 0.0058, 0.0)</code></pre><h3 id="Numerical-and-Automatic-Differentiation"><a class="docs-heading-anchor" href="#Numerical-and-Automatic-Differentiation">Numerical and Automatic Differentiation</a><a id="Numerical-and-Automatic-Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-and-Automatic-Differentiation" title="Permalink"></a></h3><p>With <a href="https://github.com/JuliaMath/Calculus.jl">Calculus.jl</a> package it is possible to perform numerical differentiation using finite differencing. You can pass in to the <code>Calculus.derivative</code> function both functions returning <code>Measurement</code> objects and a <code>Measurement</code> as the point in which to calculate the derivative.</p><pre><code class="language-julia-repl">julia&gt; using Measurements, Calculus

julia&gt; a = -45.7 ± 1.6
-45.7 ± 1.6

julia&gt; b = 36.5 ± 6.0
36.5 ± 6.0

julia&gt; Calculus.derivative(exp, a) ≈ exp(a)
true

julia&gt; Calculus.derivative(cos, b) ≈ -sin(b)
true

julia&gt; Calculus.derivative(t -&gt; log(-t * b)^2, a) ≈ 2log(-a * b)/a
true</code></pre><p>Other packages provide <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a> methods. Here is an example with <a href="https://github.com/denizyuret/AutoGrad.jl">AutoGrad.jl</a>, just one of the packages available:</p><pre><code class="language-julia-repl">julia&gt; using Measurements, AutoGrad

julia&gt; a = -45.7 ± 1.6
-45.7 ± 1.6

julia&gt; b = 36.5 ± 6.0
36.5 ± 6.0

julia&gt; grad(exp)(a) ≈ exp(a)
true

julia&gt; grad(cos)(b) ≈ -sin(b)
true

julia&gt; grad(t -&gt; log(-t * b)^2)(a) ≈ 2log(-a * b)/a
true</code></pre><p>However remember that you can always use <a href="../usage/#Measurements.derivative"><code>Measurements.derivative</code></a> to compute the value (without uncertainty) of the derivative of a <code>Measurement</code> object.</p><h3 id="Use-with-Unitful.jl"><a class="docs-heading-anchor" href="#Use-with-Unitful.jl">Use with <code>Unitful.jl</code></a><a id="Use-with-Unitful.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Use-with-Unitful.jl" title="Permalink"></a></h3><p>You can use <code>Measurements.jl</code> in combination with <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a> in order to perform calculations involving physical measurements, i.e.  numbers with uncertainty and physical unit.  You only have to use the <code>Measurement</code> object as the value of the <code>Quantity</code> object. Here are a few examples.</p><pre><code class="language-julia-repl">julia&gt; using Measurements, Unitful

julia&gt; hypot((3 ± 1)*u&quot;m&quot;, (4 ± 2)*u&quot;m&quot;) # Pythagorean theorem
5.0 ± 1.7 m

julia&gt; (50 ± 1)*u&quot;Ω&quot; * (13 ± 2.4)*1e-2*u&quot;A&quot; # Ohm&#39;s Law
6.5 ± 1.2 A Ω

julia&gt; 2pi*sqrt((5.4 ± 0.3)*u&quot;m&quot; / ((9.81 ± 0.01)*u&quot;m/s^2&quot;)) # Pendulum&#39;s period
4.66 ± 0.13 s</code></pre><h2 id="Integration-with-Plots.jl"><a class="docs-heading-anchor" href="#Integration-with-Plots.jl">Integration with <code>Plots.jl</code></a><a id="Integration-with-Plots.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-with-Plots.jl" title="Permalink"></a></h2><p><code>Measurements.jl</code> provides plot recipes for the Julia graphic framework <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>. Arguments to <code>plot</code> function that have <code>Measurement</code> type will be automatically represented with errorbars.</p><pre><code class="language-julia">julia&gt; using Measurements, Plots

julia&gt; plot(sin, [x ± 0.1 for x in 1:0.2:10], size = (1200, 800))</code></pre><p><img src="../plot-example.png" alt="image"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usage/">« Usage</a><a class="docs-footer-nextpage" href="../performance/">Performance »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 1 June 2021 23:09">Tuesday 1 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
